%!PS-Adobe-3.0
%%Title: XMLServer.pm, BooleanField.pm, DateField.pm, DateTimeField.pm, Field.pod, NumberField.pm, TextField.pm, xmlout.xsl
%%For: Michiel van Loon
%%Creator: a2ps version 4.13
%%CreationDate: Wed Sep  9 16:55:04 2009
%%BoundingBox: 24 24 588 768
%%DocumentData: Clean7Bit
%%Orientation: Landscape
%%Pages: 19
%%PageOrder: Ascend
%%DocumentMedia: Letter 612 792 0 () ()
%%DocumentNeededResources: font Courier
%%+ font Courier-Bold
%%+ font Courier-BoldOblique
%%+ font Courier-Oblique
%%+ font Helvetica
%%+ font Helvetica-Bold
%%+ font Symbol
%%+ font Times-Bold
%%+ font Times-Roman
%%DocumentProcessColors: Black 
%%DocumentSuppliedResources: procset a2ps-a2ps-hdr
%%+ procset a2ps-black+white-Prolog
%%+ encoding ISO-8859-1Encoding
%%EndComments
/a2psdict 200 dict def
a2psdict begin
%%BeginProlog
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Check PostScript language level.
/languagelevel where {
  pop /gs_languagelevel languagelevel def
} {
  /gs_languagelevel 1 def
} ifelse

% EPSF import as in the Red Book
/BeginInclude {
  /b4_Inc_state save def    		% Save state for cleanup
  /dict_count countdictstack def	% Count objects on dict stack
  /op_count count 1 sub def		% Count objects on operand stack 
  userdict begin
    0 setgray 0 setlinecap
    1 setlinewidth 0 setlinejoin
    10 setmiterlimit [ ] 0 setdash newpath
    gs_languagelevel 1 ne {
      false setstrokeadjust false setoverprint 
    } if
} bind def

/EndInclude {
  count op_count sub { pos } repeat	% Clean up stacks
  countdictstack dict_count sub { end } repeat
  b4_Inc_state restore
} bind def

/BeginEPSF {
  BeginInclude
  /showpage { } def
} bind def

/EndEPSF {
  EndInclude
} bind def

% Page prefeed
/page_prefeed {         % bool -> -
  statusdict /prefeed known {
    statusdict exch /prefeed exch put
  } {
    pop
  } ifelse
} bind def

/deffont {
  findfont exch scalefont def
} bind def

/reencode_font {
  findfont reencode 2 copy definefont pop def
} bind def

% Function c-show (str => -)
% centers text only according to x axis.
/c-show { 
  dup stringwidth pop
  2 div neg 0 rmoveto
  show
} bind def

% Function l-show (str => -)
% prints texts so that it ends at currentpoint
/l-show {
  dup stringwidth pop neg 
  0 
  rmoveto show
} bind def

% center-fit show (str w => -)
% show centered, and scale currentfont so that the width is less than w
/cfshow {
  exch dup stringwidth pop
  % If the title is too big, try to make it smaller
  3 2 roll 2 copy
  gt
  { % if, i.e. too big
    exch div
    currentfont exch scalefont setfont
  } { % ifelse
    pop pop 
  }
  ifelse
  c-show			% center title
} bind def

% Return the y size of the current font
% - => fontsize
/currentfontsize {
  currentfont /FontMatrix get 3 get 1000 mul
} bind def

% reencode the font
% <encoding-vector> <fontdict> -> <newfontdict>
/reencode { %def
  dup length 5 add dict begin
    { %forall
      1 index /FID ne 
      { def }{ pop pop } ifelse
    } forall
    /Encoding exch def

    % Use the font's bounding box to determine the ascent, descent,
    % and overall height; don't forget that these values have to be
    % transformed using the font's matrix.
    % We use `load' because sometimes BBox is executable, sometimes not.
    % Since we need 4 numbers an not an array avoid BBox from being executed
    /FontBBox load aload pop
    FontMatrix transform /Ascent exch def pop
    FontMatrix transform /Descent exch def pop
    /FontHeight Ascent Descent sub def

    % Define these in case they're not in the FontInfo (also, here
    % they're easier to get to.
    /UnderlinePosition 1 def
    /UnderlineThickness 1 def
    
    % Get the underline position and thickness if they're defined.
    currentdict /FontInfo known {
      FontInfo
      
      dup /UnderlinePosition known {
	dup /UnderlinePosition get
	0 exch FontMatrix transform exch pop
	/UnderlinePosition exch def
      } if
      
      dup /UnderlineThickness known {
	/UnderlineThickness get
	0 exch FontMatrix transform exch pop
	/UnderlineThickness exch def
      } if
      
    } if
    currentdict 
  end 
} bind def

% Function print line number (<string> # -)
/# {
  gsave
    sx cw mul neg 2 div 0 rmoveto
    f# setfont
    c-show
  grestore
} bind def

% -------- Some routines to enlight plain b/w printings ---------

% Underline
% width --
/dounderline {
  currentpoint
  gsave
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    0 rlineto
    stroke
  grestore
} bind def

% Underline a string
% string --
/dounderlinestring {
  stringwidth pop
  dounderline
} bind def

/UL {
  /ul exch store
} bind def

% Draw a box of WIDTH wrt current font
% width --
/dobox {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    stroke
  grestore
} bind def

/BX {
  /bx exch store
} bind def

% Box a string
% string --
/doboxstring {
  stringwidth pop
  dobox
} bind def

%
% ------------- Color routines ---------------
%
/FG /setrgbcolor load def

% Draw the background
% width --
/dobackground {
  currentpoint
  gsave
    newpath
    moveto
    0 currentfont /Descent get currentfontsize mul rmoveto
    dup 0 rlineto
    0 currentfont /FontHeight get currentfontsize mul rlineto
    neg 0 rlineto
    closepath
    bgcolor aload pop setrgbcolor
    fill
  grestore
} bind def

% Draw bg for a string
% string --
/dobackgroundstring {
  stringwidth pop
  dobackground
} bind def


/BG {
  dup /bg exch store
  { mark 4 1 roll ] /bgcolor exch store } if
} bind def


/Show {
  bg { dup dobackgroundstring } if
  ul { dup dounderlinestring } if
  bx { dup doboxstring } if
  show
} bind def

% Function T(ab), jumps to the n-th tabulation in the current line
/T {
  cw mul x0 add
  bg { dup currentpoint pop sub dobackground } if
  ul { dup currentpoint pop sub dounderline } if
  bx { dup currentpoint pop sub dobox } if
  y0 moveto
} bind def

% Function n: move to the next line
/n {
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

/S {
  Show
} bind def

%%BeginResource: procset a2ps-a2ps-hdr 2.0 2
%%Copyright: (c) 1988, 89, 90, 91, 92, 93 Miguel Santana
%%Copyright: (c) 1995, 96, 97, 98 Akim Demaille, Miguel Santana
% Function title: prints page header.
% <ct> <rt> <lt> are passed as argument
/title { 
  % 1. Draw the background
  x v get y v get moveto
  gsave
    0 th 2 div neg rmoveto 
    th setlinewidth
    0.95 setgray
    pw 0 rlineto stroke
  grestore
  % 2. Border it
  gsave
    0.7 setlinewidth
    pw 0 rlineto
    0 th neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
  % stk: ct rt lt
  x v get y v get th sub 1 add moveto
%%IncludeResource: font Helvetica
  fHelvetica fnfs 0.8 mul scalefont setfont
  % 3. The left title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    fnfs 0.8 mul hm rmoveto
    show			% left title
  grestore
  exch
  % stk: ct ltw rt
  % 4. the right title
  gsave
    dup stringwidth pop fnfs 0.8 mul add exch % leave space took on stack
    dup
    pw exch stringwidth pop fnfs 0.8 mul add sub
    hm
    rmoveto
    show			% right title
  grestore
  % stk: ct ltw rtw
  % 5. the center title
  gsave
    pw 3 1 roll
    % stk: ct pw ltw rtw
    3 copy 
    % Move to the center of the left room
    sub add 2 div hm rmoveto
    % What is the available space in here?
    add sub fnfs 0.8 mul sub fnfs 0.8 mul sub
    % stk: ct space_left
%%IncludeResource: font Helvetica-Bold
  fHelvetica-Bold fnfs scalefont setfont
    cfshow
  grestore
} bind def

% Function border: prints virtual page border
/border { %def
  gsave				% print four sides
    0 setgray
    x v get y v get moveto
    0.7 setlinewidth		% of the square
    pw 0 rlineto
    0 ph neg rlineto
    pw neg 0 rlineto
    closepath stroke
  grestore
} bind def

% Function water: prints a water mark in background
/water { %def
  gsave
    scx scy moveto rotate
%%IncludeResource: font Times-Bold
  fTimes-Bold 100 scalefont setfont
    .97 setgray
    dup stringwidth pop 2 div neg -50 rmoveto
    show
  grestore
} bind def

% Function rhead: prints the right header
/rhead {  %def
  lx ly moveto
  fHelvetica fnfs 0.8 mul scalefont setfont
  l-show
} bind def

% Function footer (cf rf lf -> -)
/footer {
  fHelvetica fnfs 0.8 mul scalefont setfont
  dx dy moveto
  show

  snx sny moveto
  l-show
  
  fnx fny moveto
  c-show
} bind def
%%EndResource
%%BeginResource: procset a2ps-black+white-Prolog 2.0 1

% Function T(ab), jumps to the n-th tabulation in the current line
/T { 
  cw mul x0 add y0 moveto
} bind def

% Function n: move to the next line
/n { %def
  /y0 y0 bfs sub store
  x0 y0 moveto
} bind def

% Function N: show and move to the next line
/N {
  Show
  /y0 y0 bfs sub store
  x0 y0 moveto
}  bind def

/S {
  Show
} bind def

/p {
  false UL
  false BX
  fCourier bfs scalefont setfont
  Show
} bind def

/sy {
  false UL
  false BX
  fSymbol bfs scalefont setfont
  Show
} bind def

/k {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/K {
  false UL
  false BX
  fCourier-Bold bfs scalefont setfont
  Show
} bind def

/c {
  false UL
  false BX
  fCourier-Oblique bfs scalefont setfont
  Show
} bind def

/C {
  false UL
  false BX
  fCourier-BoldOblique bfs scalefont setfont
  Show 
} bind def

/l {
  false UL
  false BX
  fHelvetica bfs scalefont setfont
  Show
} bind def

/L {
  false UL
  false BX
  fHelvetica-Bold bfs scalefont setfont
  Show 
} bind def

/str{
  false UL
  false BX
  fTimes-Roman bfs scalefont setfont
  Show
} bind def

/e{
  false UL
  true BX
  fHelvetica-Bold bfs scalefont setfont
  Show
} bind def

%%EndResource
%%EndProlog
%%BeginSetup
%%IncludeResource: font Courier
%%IncludeResource: font Courier-Oblique
%%IncludeResource: font Courier-Bold
%%IncludeResource: font Times-Roman
%%IncludeResource: font Symbol
%%IncludeResource: font Courier-BoldOblique
%%BeginResource: encoding ISO-8859-1Encoding
/ISO-8859-1Encoding [
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclam /quotedbl /numbersign /dollar /percent /ampersand /quoteright 
/parenleft /parenright /asterisk /plus /comma /minus /period /slash 
/zero /one /two /three /four /five /six /seven 
/eight /nine /colon /semicolon /less /equal /greater /question 
/at /A /B /C /D /E /F /G 
/H /I /J /K /L /M /N /O 
/P /Q /R /S /T /U /V /W 
/X /Y /Z /bracketleft /backslash /bracketright /asciicircum /underscore 
/quoteleft /a /b /c /d /e /f /g 
/h /i /j /k /l /m /n /o 
/p /q /r /s /t /u /v /w 
/x /y /z /braceleft /bar /braceright /asciitilde /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef /.notdef 
/space /exclamdown /cent /sterling /currency /yen /brokenbar /section 
/dieresis /copyright /ordfeminine /guillemotleft /logicalnot /hyphen /registered /macron 
/degree /plusminus /twosuperior /threesuperior /acute /mu /paragraph /bullet 
/cedilla /onesuperior /ordmasculine /guillemotright /onequarter /onehalf /threequarters /questiondown 
/Agrave /Aacute /Acircumflex /Atilde /Adieresis /Aring /AE /Ccedilla 
/Egrave /Eacute /Ecircumflex /Edieresis /Igrave /Iacute /Icircumflex /Idieresis 
/Eth /Ntilde /Ograve /Oacute /Ocircumflex /Otilde /Odieresis /multiply 
/Oslash /Ugrave /Uacute /Ucircumflex /Udieresis /Yacute /Thorn /germandbls 
/agrave /aacute /acircumflex /atilde /adieresis /aring /ae /ccedilla 
/egrave /eacute /ecircumflex /edieresis /igrave /iacute /icircumflex /idieresis 
/eth /ntilde /ograve /oacute /ocircumflex /otilde /odieresis /divide 
/oslash /ugrave /uacute /ucircumflex /udieresis /yacute /thorn /ydieresis 
] def
%%EndResource
% Initialize page description variables.
/sh 612 def
/sw 792 def
/llx 24 def
/urx 768 def
/ury 588 def
/lly 24 def
/#copies 1 def
/th 15.000000 def
/fnfs 11 def
/bfs 7.493857 def
/cw 4.496314 def

% Dictionary for ISO-8859-1 support
/iso1dict 8 dict begin
  /fCourier ISO-8859-1Encoding /Courier reencode_font
  /fCourier-Bold ISO-8859-1Encoding /Courier-Bold reencode_font
  /fCourier-BoldOblique ISO-8859-1Encoding /Courier-BoldOblique reencode_font
  /fCourier-Oblique ISO-8859-1Encoding /Courier-Oblique reencode_font
  /fHelvetica ISO-8859-1Encoding /Helvetica reencode_font
  /fHelvetica-Bold ISO-8859-1Encoding /Helvetica-Bold reencode_font
  /fTimes-Bold ISO-8859-1Encoding /Times-Bold reencode_font
  /fTimes-Roman ISO-8859-1Encoding /Times-Roman reencode_font
currentdict end def
/bgcolor [ 0 0 0 ] def
/bg false def
/ul false def
/bx false def
% The font for line numbering
/f# /Helvetica findfont bfs .6 mul scalefont def
/fSymbol /Symbol findfont def
/hm fnfs 0.25 mul def
/pw
   cw 81.400000 mul
def
/ph
   522.321860 th add
def
/pmw urx llx sub pw 2 mul sub 1 div def
/pmh 0 def
/v 0 def
/x [
  0
  dup pmw add pw add
] def
/y [
  pmh ph add 0 mul ph add
  dup
] def
/scx sw 2 div def
/scy sh 2 div def
/snx urx def
/sny lly 2 add def
/dx llx def
/dy sny def
/fnx scx def
/fny dy def
/lx snx def
/ly ury fnfs 0.8 mul sub def
/sx 0 def
/tab 8 def
/x0 0 def
/y0 0 def
%%EndSetup

%%Page: (1-2) 1
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(# $Id: XMLServer.pm,v 1.19 2005/11/15 22:03:01 mjb47 Exp $) c n
() p n
(use) K
( ) p
(strict) L
(;) p n
(use) K
( ) p
(warnings) L
(;) p n
(use) K
( ) p
(XML::LibXML) L
(;) p n
(use) K
( ) p
(XML::LibXSLT) L
(;) p n
() N
(package) K
( DBIx::XMLServer;) p n
() N
(our $VERSION = ') S
(0.02) str
(';) p n
() N
(my) K
( $our_ns = ') p
(http://boojum.org.uk/NS/XMLServer) str
(';) p n
() N
(my) K
( $sql_ns = ) p
(sub) K
( {) p n
(  ) S
(my) K
( $node = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $uri = ) p
(shift) K
( || $our_ns;) p n
(  ) S
(my) K
( $prefix;) p n
(  $prefix = $node->lookupNamespacePrefix\($uri\) ) S
(and) K
( ) p
(return) K
( $prefix;) p n
(  ) S
(for) K
(\($prefix = ') p
(a) str
('; $node->lookupNamespaceURI\($prefix\); ++$prefix\) {}) p n
(  $node->setNamespace\($uri, $prefix, 0\);) N
(  ) S
(return) K
( $prefix;) p n
(};) N
() N
(package) K
( DBIx::XMLServer::Field;) p n
(use) K
( ) p
(Carp) L
(;) p n
() N
(our $VERSION = ) S
(sprintf) K
( ') p
(%d.%03d) str
(', \() p
(q) K
($Revision: 1.19 $ =~ /\(\\d+\)\\.\(\\d+\)/\);) p n
() N
(sub) K
( ) p
(new) L
( {) p n
(  ) S
(my) K
( $proto = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $class = ) p
(ref) K
(\($proto\) || $proto;) p n
(  ) S
(my) K
( $self = {};) p n
(  $self->{XMLServer} = ) S
(shift) K n
(    ) p
(and) K
( ) p
(ref) K
( $self->{XMLServer}) p n
(      ) S
(and) K
( $self->{XMLServer}->isa\(') p
(DBIx::XMLServer) str
('\)) p n
() S 8 T () S
(or) K
( croak ") p
(No XMLServer object supplied) str
(";) p n
(  $self->{node} = ) S
(shift) K n
(    ) p
(and) K
( ) p
(ref) K
( $self->{node}) p n
(      ) S
(and) K
( $self->{node}->isa\(') p
(XML::LibXML::Element) str
('\)) p n
() S 8 T () S
(or) K
( croak ") p
(No XML element node supplied) str
(";) p n
(  $self->{node}->namespaceURI ) S
(eq) K
( $our_ns) p n
(    ) S
(and) K
( $self->{node}->localname ) p
(eq) K
( ') p
(field) str
(') p n
(      ) S
(or) K
( croak ") p
(The node is not an <sql:field> element) str
(";) p n
(  ) S
(my) K
( $type = $self->{node}->getAttribute\(') p
(type) str
('\)) p n
(    ) S
(or) K
( croak ") p
(<sql:field> element has no `type' attribute) str
(";) p n
(  $class = $self->{XMLServer}->{types}->{$type}) N
(    ) S
(or) K
( croak ") p
(Undefined field type: `$type') str
(";) p n
(  ) S
(bless) K
(\($self, $class\);) p n
(  $self->init ) S
(if) K
( $self->can\(') p
(init) str
('\);) p n
(  ) S
(return) K
( $self;) p n
(}) N
() N
(sub) K
( ) p
(where) L
( { ) p
(return) K
( ') p
(1) str
('; }) p n
() N
(sub) K
( ) p
(select) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $expr = $self->{node}->getAttribute\(') p
(expr) str
('\)) p n
(    ) S
(or) K
( ) p
(die) K
( ") p
(A <sql:field> element has no `expr' attribute) str
(";) p n
(  ) S
(return) K
( $expr;) p n
(}) N
() N
(sub) K
( ) p
(join) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(return) K
( $self->{node}->getAttribute\(') p
(join) str
('\);) p n
(}) N
() N
(sub) K
( ) p
(value) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(return) K
( ) p
(shift) K
( @{) p
(shift) K
(\(\)};) p n
(XMLServer.pm) (Page 1/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(}) p n
() N
(sub) K
( ) p
(result) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $n = ) p
(shift) K
(;) p n
() N
(  ) S
(my) K
( $value = $self->value\() p
(shift) K
(\(\)\);) p n
() N
(  ) S
(do) K
( {) p n
(    $value = $n->ownerDocument->createElementNS\($our_ns, ') S
(sql:null) str
('\);) p n
(    $value->setAttribute\(') S
(type) str
(',) p n
() S 8 T () S 16 T () S 24 T ( $self->{node}->getAttribute\(') S
(null) str
('\) || ') p
(empty) str
('\);) p n
(  } ) S
(unless) K
( ) p
(defined) K
( $value;) p n
() N
(  ) S
(do) K
( {) p n
(    ) S
(my) K
( $x = $n->ownerDocument->createTextNode\($value\);) p n
(    $value = $x;) N
(  } ) S
(unless) K
( ) p
(ref) K
( $value;) p n
() N
(  ) S
(my) K
( $attr = $self->{node}->getAttribute\(') p
(attribute) str
('\);) p n
() N
(  ) S
(if) K
(\($attr\) {) p n
(    ) S
(my) K
( $x = $n->ownerDocument->createElementNS\($our_ns, ') p
(sql:attribute) str
('\);) p n
(    $x->setAttribute\(') S
(name) str
(', $attr\);) p n
(    $x->appendChild\($value\);) N
(    $value = $x;) N
(  }) N
() N
(  $n->replaceNode\($value\);) N
(}) N
() N
(1;) N
() N
(package) K
( DBIx::XMLServer::OrderSpec;) p n
() N
(our $VERSION = ) S
(sprintf) K
( ') p
(%d.%03d) str
(', \() p
(q) K
($Revision: 1.19 $ =~ /\(\\d+\)\\.\(\\d+\)/\);) p n
() N
(sub) K
( ) p
(new) L
( {) p n
(  ) S
(my) K
( $proto = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $class = ) p
(ref) K
(\($proto\) || $proto;) p n
(  ) S
(my) K
( $self = {};) p n
() N
(  ) S
(my) K
( \($xmlserver, $node, $dir\) = @_;) p n
(  $self->{field} = new DBIx::XMLServer::Field\($xmlserver, $node\);) N
(  $self->{dir} = $dir;) N
() N
(  ) S
(bless) K
(\($self, $class\);) p n
(  ) S
(return) K
( $self;) p n
(}) N
() N
(sub) K
( ) p
(orderspec) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $spec = $self->{field}->) p
(select) K
(;) p n
(  ) S
(for) K
( \($self->{dir}\) {) p n
(    ) S
(defined) K
( $_ ) p
(or) K
( ) p
(last) K
(;) p n
(    /^ascending$/ && ) S
(do) K
( {) p n
(      $spec .= ') S
( ASC) str
(';) p n
(      ) S
(last) K
(;) p n
(    };) N
(    /^descending$/ && ) S
(do) K
( {) p n
(      $spec .= ') S
( DESC) str
(';) p n
(      ) S
(last) K
(;) p n
(    };) N
(  }) N
(  ) S
(return) K
( $spec;) p n
(}) N
() N
(1;) N
() N
(XMLServer.pm) (Page 2/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (1/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (3-4) 2
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(package) K
( DBIx::XMLServer::Request;) p n
(use) K
( ) p
(Carp) L
(;) p n
(use) K
( ) p
(Text::Balanced) L
( ) p
(qw) K
(\(extract_bracketed\);) p n
() N
(our $VERSION = ) S
(sprintf) K
( ') p
(%d.%03d) str
(', \() p
(q) K
($Revision: 1.19 $ =~ /\(\\d+\)\\.\(\\d+\)/\);) p n
() N
(if) K
( \($^V ) p
(lt) K
( v5.7\)) p n
({) N
(  ) S
(require) K
( ) p
(Exporter) L
(;) p n
(  our @ISA = ) S
(qw) K
(\(Exporter\);) p n
(  our @EXPORT = ) S
(qw) K
(\(IsNCNameStartChar IsNCNameChar\);) p n
(}) N
() N
(# Look for an initial segment of the string which looks like an XPath) c n
(# pattern) N
(sub) K
( ) p
(get_xpath) L
( {) p n
(  ) S
(my) K
( $text = ) p
(shift) K
(;) p n
() N
(  ) S
(# Repeatedly skip XPath-like stuff and bracketed things) c n
(  ) p
(while) K
(\( \(extract_bracketed\($text, ") p
([\(\\"') str
(",) p n
() S 8 T () S 16 T () S 24 T (    ') S
([-|@_./:[:alnum:][:space:]]*) str
('\)\) [0]\) {};) p n
(  ) S
(# Skip any more XPath-like stuff) c n
(  $text =~ ) p
(m) K
('\\G[-|@_./:[:alnum:][:space:]]*'g;) p n
() N
(  ) S
(return) K
( ) p
(substr) K
(\($text, 0, pos $text\), ) p
(substr) K
(\($text, pos $text\);) p n
(}) N
() N
(BEGIN) K
( {) p n
(  ) S
(# This hack is because Perl 5.6.1 appears to be buggy and not) c n
(  ) p
(# allow unicode character properties to be declared in a package) c n
(  ) p
(# pther than main.) c n
(  our $property_package = $^V ) p
(lt) K
( v5.8 ? ') p
(main) str
(' : ') p
(DBIx::XMLServer::Request) str
(';) p n
(  ) S
(eval) K
( <<END_PROPERTIES;) p n
(  ) S
(package) K
( $property_package;) p n
() N
(  ) S
(# These are the ranges defined by XML 1.1, as these) c n
(  ) p
(# are more up-to-date w.r.t Unicode those defined by) c n
(  ) p
(# XML 1.0 \(3rd ed\).  They're also much simpler to specify.) c n
(  ) p
(sub) K
( ) p
(IsNCNameStartChar) L
( {) p n
(      ) S
(return) K
( <<) p
(END) K
(;) p n
(41) S 8 T (5A) N
(5F) N
(61) S 8 T (7A) N
(C0) S 8 T (D6) N
(D8) S 8 T (F6) N
(F8) S 8 T (2FF) N
(370) S 8 T (37D) N
(37F) S 8 T (1FFF) N
(200C) S 8 T (200D) N
(2070) S 8 T (218F) N
(2C00) S 8 T (2FEF) N
(3001) S 8 T (D7FF) N
(F900) S 8 T (FDCF) N
(FDF0) S 8 T (FFFD) N
(10000) S 8 T (EFFFF) N
(END) K n
(  }) p n
() N
(  ) S
(sub) K
( ) p
(IsNCNameChar) L
( {) p n
(      ) S
(return) K
( <<) p
(END) K
(;) p n
(2D) S 8 T (2E) N
(30) S 8 T (39) N
(41) S 8 T (5A) N
(5F) N
(61) S 8 T (7A) N
(B7) N
(C0) S 8 T (D6) N
(D8) S 8 T (F6) N
(F8) S 8 T (2FF) N
(XMLServer.pm) (Page 3/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(300) p 8 T (36F) N
(370) S 8 T (37D) N
(37F) S 8 T (1FFF) N
(200C) S 8 T (200D) N
(203F) S 8 T (2040) N
(2070) S 8 T (218F) N
(2C00) S 8 T (2FEF) N
(3001) S 8 T (D7FF) N
(F900) S 8 T (FDCF) N
(FDF0) S 8 T (FFFD) N
(10000) S 8 T (EFFFF) N
(END) K n
(  }) p n
() N
(END_PROPERTIES) N
(}) N
() N
(# Definition of NCName as per XML Namespaces 1.1) c n
(use) K
( ) p
(utf8) L
(;) p n
(our $NCName = qr/\(?:\\p{IsNCNameStartChar}\\p{IsNCNameChar}*\)/;) N
() N
(sub) K
( ) p
(add_prefix\($$\)) L
( {) p n
() N
(  ) S
(my) K
( \( $xpath, $prefix \) = @_;) p n
() N
(  ) S
(while) K
( \( $xpath =~ s/) p n
(            ^\( \(?:[^') S
("]*\(?:"[^"]*"|) str
('[^') p
(]*) str
('\)\)*[^') p
("]*) str n
(               \(?: \(?<!attribute|namespace\)\(?<!\\s\)\\s*::\\s*) N
(                 | \(?: \(?: \(?<=[\\@\([,\\/|+-=<>]\)) N
(                         | \(?<=[<>!]=|\\/\\/|::\) ) N
(                         | ^\) ) N
(                       \(?: $NCName\\s+ $NCName\\s+ \)*) N
(                     | \(?: \(?<=[.\\]\)") S
(']\)) p n
(                         | [0-9]+\(?:\\.[0-9]+\)?\\s) N
(                         | \\$$NCName\(?::$NCName\)?\\s \) ) N
(                       \\s* $NCName\\s+) N
(                       \(?: $NCName\\s+ $NCName\\s+ \)* \)) N
(                   \(?<![:\\$\\@]|\\p{IsNCNameChar}\) \) \)) N
(            \($NCName\)) N
(            \(\\s+[^:\(\\s]|\\s*\(?![:\(\\s]\)\\P{IsNCNameChar}|$\)) N
(          /$1$prefix:$2$3/) S
(x) K
( \) {}) p n
() N
(  ) S
(return) K
( $xpath;) p n
(}) N
() N
(sub) K
( ) p
(new) L
( {) p n
(  ) S
(my) K
( $proto = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $class = ) p
(ref) K
(\($proto\) || $proto;) p n
(  ) S
(my) K
( $self;) p n
(  ) S
(if) K
(\($#_ <= 1\) {) p n
(    $self = {};) N
(    $self->{XMLServer} = ) S
(shift) K
(;) p n
(    $self->{template} = ) S
(shift) K
(;) p n
(  } ) S
(else) K
( {) p n
(    $self = { @_ };) N
(  };) N
(  ) S
(ref) K
( $self->{XMLServer}) p n
(    ) S
(and) K
( $self->{XMLServer}->isa\(') p
(DBIx::XMLServer) str
('\) ) p n
(      ) S
(or) K
( croak ") p
(No XMLServer object supplied) str
(";) p n
() N
(  $self->{template} ) S
(or) K
( $self->{template} = $self->{XMLServer}->{template};) p n
(  $self->{template}->isa\(') S
(XML::LibXML::Element) str
('\)) p n
(    ) S
(or) K
( croak ") p
(Template is not a XML::LibXML::Element) str
(";) p n
() N
(  $self->{template}->localname ) S
(eq) K
( ') p
(template) str
(') p n
(    && $self->{template}->namespaceURI ) S
(eq) K
( $our_ns) p n
(      ) S
(or) K
( croak ") p
(Template is not <sql:template>) str
(";) p n
(  $self->{main_table} = $self->{template}->getAttribute\(') S
(table) str
('\)) p n
(    ) S
(or) K
( croak ") p
(The <sql:template> element has no `table' attribute) str
(";) p n
(XMLServer.pm) (Page 4/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (2/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (5-6) 3
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  $self->{ns} = $self->{template}->getAttribute\(') p
(default-namespace) str
('\);) p n
(  ) S
(my) K
( $p = &$sql_ns\($self->{template}\);) p n
(  $self->{record} = $self->{template}->findnodes\(") S
(.//$p:record/*[1]) str
("\)->) p
(shift) K n
(    ) p
(or) K
( croak ") p
(The <sql:template> element contains no <sql:record> element) str
(";) p n
() N
(  $self->{criteria} = [];) N
(  $self->{page} = 0;) N
(  $self->{pagesize} = $self->{XMLServer}->{maxpagesize}) N
(    ) S
(unless) K
( ) p
(defined) K
( $self->{pagesize};) p n
(  $self->{rowcount} = $self->{XMLServer}->{rowcount}) N
(    ) S
(unless) K
( ) p
(defined) K
( $self->{rowcount};) p n
(  ) S
(bless) K
(\($self, $class\);) p n
(  ) S
(return) K
( $self;) p n
(}) N
() N
(sub) K
( ) p
(real_parse) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $query = ) p
(shift) K
( ) p
(or) K
( croak ") p
(No query string supplied) str
(";) p n
(  ) S
(foreach) K
(\() p
(split) K
( /&/, $query\) {) p n
(    ) S
(# Un-URL-encode the string) c n
(    ) p
(tr) K
(/+/ /;) p n
(    ) S
(s) K
(/%\([0-9A-Fa-f][0-9A-Fa-f]\)/chr\(hex\($1\)\)/eg;) p n
(    ) S
(# Split it into key and condition) c n
(    ) p
(my) K
( \($key, $condition\) = get_xpath\($_\);) p n
(    $key ) S
(or) K
( ) p
(return) K
( ") p
(Unrecognised condition: '$condition') str
(";) p n
(    ) S
(for) K
( \($key\) {) p n
(      /^fields$/ && ) S
(do) K
( {) p n
() S 8 T ($condition =~ ) S
(s) K
(/^=// ) p n
() S 8 T (  ) S
(or) K
( ) p
(return) K
( ") p
(Expected '=' after 'fields' but found '$condition') str
(";) p n
() S 8 T ($self->{fields} = $condition;) N
() S 8 T () S
(last) K
(; ) p n
(      };) N
(      /^order$/ && ) S
(do) K
( {) p n
() S 8 T ($condition =~ ) S
(s) K
(/^=//) p n
() S 8 T (  ) S
(or) K
( ) p
(return) K
( ") p
(Expected '=' after 'order' but found '$condition') str
(";) p n
() S 8 T ($self->{order} = $condition;) N
() S 8 T () S
(last) K
(;) p n
(      };) N
(      /^page$/ && ) S
(do) K
( { ) p
(# The page number) c n
(        $condition =~ /^=\([1-9]\\d*\)$/) p n
() S 8 T (  ) S
(or) K
( ) p
(return) K
( ") p
(Unrecognised page number: $condition) str
(";) p n
() S 8 T ($self->{page} = $1 - 1;) N
() S 8 T () S
(last) K
(;) p n
(      };) N
(      /^pagesize$/ && ) S
(do) K
( { ) p
(# The page size) c n
(        $condition =~ /^=\(\\d+\)$/) p n
() S 8 T (  ) S
(or) K
( ) p
(return) K
( ") p
(Unrecognised page size: $condition) str
(";) p n
() S 8 T ($self->{pagesize} = $1;) N
() S 8 T () S
(defined) K
(\($self->{XMLServer}->{maxpagesize}\)) p n
() S 8 T (  && $self->{XMLServer}->{maxpagesize} > 0) N
(          ) S
(and) K
( \( \($1 > 0 && $1 <= $self->{XMLServer}->{maxpagesize}\)) p n
() S 8 T (    ) S
(or) K
( ) p
(return) K
( ") p
(Invalid page size: Must be between 1 ) str
(" .) p n
() S 8 T (      ") S
(and $self->{XMLServer}->{maxpagesize}) str
("\);) p n
() S 8 T () S
(last) K
(;) p n
(      };) N
(      /^format$/ && $self->{userformat} && ) S
(do) K
( {) p n
(          $condition =~ ) S
(s) K
(/^=// ) p n
(            ) S
(or) K
( ) p
(return) K
( ") p
(Expected '=' after 'format' but found '$condition') str
(";) p n
(          ) S
(my) K
( $root = $self->{XMLServer}->{doc}->documentElement;) p n
(          ) S
(my) K
( $p = &$sql_ns\($root\);) p n
() S 8 T (  $self->{template} = $root->findnodes\(") S
(/$p:spec/$p:template[@) str
(" ) p n
() S 8 T () S 16 T () S 24 T () S 32 T () S 40 T (       . ") S
(id='$condition']) str
("\)->) p
(shift) K n
() p 8 T (    ) S
(or) K
( ) p
(return) K
( ") p
(Invalid format.  Must be one of ) str
(") p n
() S 8 T (      . ) S
(join) K
(\(') p
(, ) str
(', map\(") p
(') str
(" . $_->value . ") p
(') str
(", ) p n
() S 8 T () S 16 T () S 24 T (       $root->findnodes\(") S
(/$p:spec/$p:template/@) str
(".") p
(id) str
("\)\)\)) p n
(              . ") S
(.) str
(";) p n
() S 8 T (  $self->{template}->localname ) S
(eq) K
( ') p
(template) str
(') p n
() S 8 T (    && $self->{template}->namespaceURI ) S
(eq) K
( $our_ns) p n
() S 8 T (    ) S
(or) K
( croak ") p
(Template is not <sql:template>) str
(";) p n
(XMLServer.pm) (Page 5/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p 8 T (  $self->{main_table} = $self->{template}->getAttribute\(') S
(table) str
('\)) p n
() S 8 T (    ) S
(or) K
( croak ") p
(The <sql:template> element has no `table' attribute) str
(";) p n
() S 8 T (  $self->{ns} = $self->{template}->getAttribute\(') S
(default-namespace) str
('\);) p n
() S 8 T (  $p = &$sql_ns\($self->{template}\);) N
() S 8 T (  $self->{record} = $self->{template}->findnodes\(") S
(.//$p:record/*[1]) str
("\)) p n
() S 8 T (    ->) S
(shift) K n
() p 8 T (    ) S
(or) K
( croak ") p
(The <sql:template> element contains no <sql:record> element) str
(";) p n
() S 8 T (  ) S
(last) K
(;) p n
() S 8 T (};) N
(      ) S
(# Anything else we treat as a search criterion) c n
(      ) p
(push) K
( @{$self->{criteria}}, [$key, $condition];) p n
(    }) N
(  }) N
(  ) S
(return) K
( ) p
(undef) K
(;) p n
(}) N
() N
(sub) K
( ) p
(do_criteria) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
() N
(  ) S
(my) K
( $prefix = $self->{ns};) p n
(  $prefix = &$sql_ns\($self->{record}, $self->{ns}\)) N
(    ) S
(if) K
( ) p
(defined) K
( $self->{ns} && $self->{ns} ) p
(ne) K
( ') p
(*) str
(';) p n
(  ) S
(my) K
( $p = &$sql_ns\($self->{record}\);) p n
(  ) S
(foreach) K
(\(@{$self->{criteria}}\) {) p n
(    ) S
(my) K
( $key = $_->[0];) p n
(    ) S
(# Fix up a default namespace) c n
(    $key = add_prefix\($key, $prefix\) ) p
(if) K
( $prefix;) p n
(    ) S
(# Find the field) c n
(    ) p
(my) K
( @nodelist = $self->{record}->findnodes\($key\);) p n
(    ) S
(my) K
( $node;) p n
(    ) S
(if) K
(\(@nodelist ) p
(eq) K
( 1 && $nodelist[0]->isa\(') p
(XML::LibXML::Attr) str
('\)\) {) p n
(      ) S
(my) K
( $name = $nodelist[0]->nodeName;) p n
(      ) S
(my) K
( $owner = $nodelist[0]->getOwnerElement;) p n
(      ) S
(my) K
( $q = &$sql_ns\($owner\);) p n
(      $node = $owner->findnodes\(") S
($q:field[@) str
(".") p
(attribute='$name']) str
("\)->) p
(shift) K n
() p 8 T () S
(or) K
( ) p
(return) K
( ") p
(Attribute '$key' isn't a field) str
(";) p n
(    } ) S
(else) K
( {) p n
(      ) S
(my) K
( @nodes = $self->{record}->findnodes ) p n
() S 8 T (\($key . ") S
(//$p:field[not\(@) str
(".") p
(attribute\)]) str
("\)) p n
() S 8 T () S
(or) K
( ) p
(return) K
( ") p
(Unknown field: '$key') str
(";) p n
(      @nodes ) S
(eq) K
( 1 ) p
(or) K
( ) p
(return) K
( ") p
(Expression '$key' selects more than one field) str
(";) p n
(      $node = ) S
(shift) K
( @nodes;) p n
(    }) N
(    $_->[0] = new DBIx::XMLServer::Field\($self->{XMLServer}, $node\);) N
(  }) N
(  ) S
(return) K
( ) p
(undef) K
(;) p n
(}) N
() N
(sub) K
( ) p
(_prune) L
( {) p n
(  ) S
(my) K
( $element = ) p
(shift) K
(;) p n
(  ) S
(if) K
(\($element->getAttributeNS\($our_ns, ') p
(keepme) str
('\)\) {) p n
(    ) S
(foreach) K
( ) p
(my) K
( $child \($element->childNodes\) {) p n
(      _prune\($child\) ) S
(if) K
( $child->isa\(') p
(XML::LibXML::Element) str
('\);) p n
(    }) N
(  } ) S
(else) K
( {) p n
(    $element->unbindNode) N
(      ) S
(unless) K
( \($element->namespaceURI || ''\) ) p
(eq) K
( $our_ns ) p
(# Hack to avoid pruning ) c n
() p 8 T (&& $element->localname ) S
(eq) K
( ') p
(field) str
('      ) p
(# attribute fields) c n
() p 8 T (  && $element->getAttribute\(') S
(attribute) str
('\);) p n
(  }) N
(}) N
() N
(sub) K
( ) p
(build_output) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $doc = ) p
(shift) K
(;) p n
() N
(  ) S
(# Create the output structure) c n
(  ) p
(my) K
( $new_template = $self->{template}->cloneNode\(1\);) p n
(  $doc->adoptNode\($new_template\);) N
(XMLServer.pm) (Page 6/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (3/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (7-8) 4
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  $doc->setDocumentElement\($new_template\);) p n
(  ) S
(my) K
( $p = &$sql_ns\($new_template\);) p n
(  ) S
(my) K
( $record = $new_template->findnodes\(") p
(.//$p:record) str
("\)->) p
(shift) K n
(    ) p
(or) K
( croak ") p
(There is no <sql:record> element in the template) str
(";) p n
(  $self->{newrecord} = $record->findnodes\(') S
(*) str
('\)->) p
(shift) K n
(    ) p
(or) K
( croak ") p
(The <sql:record> element has no child element) str
(";) p n
() N
(  $self->{rowcount} = ') S
(NONE) str
(') p n
(    ) S
(unless) K
( $new_template->findnodes\(") p
(.//$p:meta[@ type='rows']) str
("\)->size\(\);) p n
() N
(  ) S
(# Find the nodes to return) c n
(  ) p
(if) K
(\() p
(defined) K
( $self->{fields}\) {) p n
(    ) S
(my) K
( $prefix = $self->{ns};) p n
(    $prefix = &$sql_ns\($self->{newrecord}, $self->{ns}\)) N
(      ) S
(if) K
( ) p
(defined) K
( $self->{ns} && $self->{ns} ) p
(ne) K
( ') p
(*) str
(';) p n
(    ) S
(my) K
( \($r, $s\) = get_xpath\($self->{fields}\);) p n
(    ) S
(return) K
( ") p
(Unexpected text: '$s') str
(" ) p
(if) K
( $s;) p n
(    $r = add_prefix\($r, $prefix\) ) S
(if) K
( $prefix;) p n
(    $self->{fields} = $r;) N
(  } ) S
(else) K
( {) p n
(    $self->{fields} = ') S
(.) str
(';) p n
(  }) N
(  ) S
(my) K
( @nodeset = $self->{newrecord}->findnodes) p n
(    \(") S
(\($self->{fields}\)/descendant-or-self::*) str
("\);) p n
(  @nodeset > 0 ) S
(or) K
( ) p
(return) K
( ") p
(No elements match expression $self->{fields}) str
(";) p n
() N
(  ) S
(# Mark the subtree containing them) c n
(  $self->{newrecord}->setAttributeNS\($our_ns, ') p
(keepme) str
(', 1\);) p n
(  ) S
(foreach) K
( ) p
(my) K
( $node \(@nodeset\) {) p n
(    ) S
(until) K
(\($node->isa\(') p
(XML::LibXML::Element) str
('\) && ) p n
() S 8 T (  $node->getAttributeNS\($our_ns, ") S
(keepme) str
("\)\) {) p n
(      $node->setAttributeNS\($our_ns, ") S
(keepme) str
(", 1\)) p n
() S 8 T () S
(if) K
( $node->isa\(') p
(XML::LibXML::Element) str
('\);) p n
(      $node = $node->parentNode;) N
(    }) N
(  }) N
() N
(  ) S
(# Find the nodes to order by) c n
(  ) p
(if) K
(\() p
(defined) K
( $self->{order}\) {) p n
(    ) S
(my) K
( $prefix = $self->{ns};) p n
(    $prefix = &$sql_ns\($self->{newrecord}, $self->{ns}\)) N
(      ) S
(if) K
( ) p
(defined) K
( $self->{ns} && $self->{ns} ) p
(ne) K
( ') p
(*) str
(';) p n
(    ) S
(my) K
( $order = $self->{order};) p n
(    ) S
(my) K
( @order;) p n
(    ) S
(while) K
( \( $order ) p
(ne) K
( '' \) {) p n
(      ) S
(my) K
( \($xpath, $more\) = get_xpath\($order\);) p n
(      $xpath = add_prefix\($xpath, $prefix\) ) S
(if) K
( $prefix;) p n
(      $xpath =~ ) S
(s) K
(/ +\(ascending|descending\) *$//;) p n
(      ) S
(my) K
( $dir = $1;) p n
(      ) S
(my) K
( @o = $self->{newrecord}->findnodes\($xpath\)) p n
() S 8 T () S
(or) K
( ) p
(return) K
( ") p
(Invalid field in order clause: $xpath\\n) str
(";) p n
(      ) S
(foreach) K
( \(@o\) {) p n
() S 8 T () S
(my) K
( @f = $_->findnodes\() p n
() S 8 T (  $_->nodeType == XML::LibXML::XML_ATTRIBUTE_NODE) N
() S 8 T (    ? ") S
(../$p:field[\\@attribute=') str
(".$_->nodeName.") p
(']) str
(") p n
() S 8 T (    : ") S
(.//$p:field) str
(" \)) p n
() S 8 T (  ) S
(or) K
( ) p
(return) K
( ") p
(No non-static data matched by order clause: $xpath\\n) str
(";) p n
() S 8 T () S
(foreach) K
( \(@f\) {) p n
() S 8 T (  ) S
(push) K
( @order,) p n
() S 8 T (    new DBIx::XMLServer::OrderSpec\($self->{XMLServer}, $_, $dir\);) N
() S 8 T (}) N
(      }) N
(      ) S
(return) K
( ") p
(Unexpected order: '$order') str
(" ) p n
() S 8 T () S
(unless) K
( $more ) p
(eq) K
( '' || $more =~ ) p
(s) K
(/^,//;) p n
(      $order = $more;) N
(    }) N
(    $self->{order} = \\@order;) N
(  }) N
() N
(XMLServer.pm) (Page 7/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  ) p
(# Prune away what we don't want to return) c n
(  _prune\($self->{newrecord}\);) p n
() N
(  ) S
(return) K
( ) p
(undef) K
(;) p n
(}) N
() N
(sub) K
( ) p
(build_fields) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( @fields;) p n
(  ) S
(my) K
( $p = &$sql_ns\($self->{newrecord}\);) p n
(  ) S
(foreach) K
(\($self->{newrecord}->findnodes\(") p
(.//$p:field) str
("\)\) {) p n
(    ) S
(push) K
( @fields, new DBIx::XMLServer::Field\($self->{XMLServer}, $_\);) p n
(  }) N
(  $self->{fields} = \\@fields;) N
(  ) S
(return) K
( ) p
(undef) K
(;) p n
(}) N
() N
(sub) K
( ) p
(add_join) L
( {) p n
(  ) S
(my) K
( \($self, $table\) = @_;) p n
(  ) S
(return) K
( ) p
(unless) K
( $table;) p n
(  ) S
(do) K
( {) p n
(    ) S
(my) K
( $root = $self->{XMLServer}->{doc}->documentElement;) p n
(    ) S
(my) K
( $p = &$sql_ns\($root\);) p n
(    ) S
(my) K
( $tabledef = $root->find\(") p
(/$p:spec/$p:table[@) str
(".") p
(name='$table']) str
("\)->) p
(shift) K n
(      ) p
(or) K
( croak ") p
(Unknown table reference: $table) str
(";) p n
(    ) S
(my) K
( $jointo = $tabledef->getAttribute\(') p
(jointo) str
('\);) p n
(    ) S
(my) K
( $join = '';) p n
(    ) S
(do) K
( {) p n
(      $self->add_join\($jointo\);) N
(      $join = ) S
(uc) K
( $tabledef->getAttribute\(') p
(join) str
('\) || '';) p n
(      $join .= ') S
( JOIN ) str
(';) p n
(    } ) S
(if) K
( $jointo;) p n
(    ) S
(my) K
( $sqlname = $tabledef->getAttribute\(') p
(sqlname) str
('\)) p n
(      ) S
(or) K
( croak ") p
(Table `$table' has no `sqlname' attribute) str
(";) p n
(    $join .= ") S
($sqlname AS $table) str
(";) p n
(    ) S
(do) K
( {) p n
(      ) S
(if) K
(\() p
(my) K
( $using = $tabledef->getAttribute\(') p
(using) str
('\)\) {) p n
() S 8 T ($join .= ") S
( ON $jointo.$using = $table.$using) str
(";) p n
(      } ) S
(elsif) K
(\() p
(my) K
( $ref = $tabledef->getAttribute\(') p
(refcolumn) str
('\)\) {) p n
() S 8 T () S
(my) K
( $key = $tabledef->getAttribute\(') p
(keycolumn) str
('\)) p n
() S 8 T (  ) S
(or) K
( croak ") p
(Table $table has `refcolumn' without `keycolumn') str
(";) p n
() S 8 T ($join .= ") S
( ON $jointo.$ref = $table.$key) str
(";) p n
(      } ) S
(elsif) K
(\() p
(my) K
( $on = $tabledef->getAttribute\(') p
(on) str
('\)\) {) p n
() S 8 T ($join .= ") S
( ON $on) str
(";) p n
(      }) N
(    } ) S
(if) K
( $jointo;) p n
(    ) S
(push) K
( @{$self->{jointext}}, $join;) p n
(    $self->{joinhash}->{$table} = 1;) N
(  } ) S
(unless) K
( $self->{joinhash}->{$table};) p n
(}) N
() N
(sub) K
( ) p
(parse) L
( {) p n
(  ) S
(my) K
( \($self, $arg\) = @_;) p n
(  ) S
(my) K
( $err;) p n
() N
(  $self->{doc} = new XML::LibXML::Document;) N
(  $self->{arg} = $arg;) N
(  $err = $self->real_parse\($arg\) ) S
(and) K
( ) p
(return) K
( $err;) p n
(  $err = $self->do_criteria ) S
(and) K
( ) p
(return) K
( $err;) p n
(  $err = $self->build_output\($self->{doc}\) ) S
(and) K
( ) p
(return) K
( $err;) p n
(  $err = $self->build_fields ) S
(and) K
( ) p
(return) K
( $err;) p n
() N
(  $self->{jointext} = [];) N
(  $self->{joinhash} = {};) N
(  $self->add_join\($self->{main_table}\);) N
(  ) S
(foreach) K
( ) p
(my) K
( $x \(@{$self->{criteria}}\) {) p n
(    ) S
(foreach) K
(\($x->[0]->) p
(join) K
(\) {) p n
(      $self->add_join\($_\);) N
(    }) N
(XMLServer.pm) (Page 8/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (4/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (9-10) 5
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  }) p n
() N
(  ) S
(my) K
( $select;) p n
(  ) S
(my) K
( $from;) p n
(  ) S
(my) K
( $where;) p n
(  ) S
(my) K
( $order;) p n
(  ) S
(my) K
( $limit;) p n
() N
(  ) S
(eval) K
( {) p n
(    $where = ) S
(join) K
(\(') p
( AND ) str
(', map\($_->[0]->where\($_->[1]\),) p n
() S 8 T () S 16 T () S 24 T () S 32 T (      @{$self->{criteria}}\)\) || ') S
(1) str
(';) p n
(    $from = ) S
(join) K
(\(') p
( ) str
(', @{$self->{jointext}}\);) p n
(  };) N
(  ) S
(return) K
( $@ ) p
(if) K
( $@;) p n
() N
(  $self->{count_query} = ") S
(SELECT COUNT\(*\) FROM $from WHERE $where) str
(";) p n
() N
(  ) S
(foreach) K
( ) p
(my) K
( $f \(@{$self->{fields}}\) {) p n
(    ) S
(foreach) K
( \($f->) p
(join) K
(\) {) p n
(      $self->add_join\($_\);) N
(    }) N
(  }) N
() N
(  ) S
(foreach) K
( ) p
(my) K
( $o \(@{$self->{order}}\) {) p n
(    ) S
(foreach) K
( \($o->{field}->) p
(join) K
(\) {) p n
(      $self->add_join\($_\);) N
(    }) N
(  }) N
() N
(  ) S
(eval) K
( {) p n
(    $select = ) S
(join) K
(\(') p
(,) str
(', map\($_->) p
(select) K
(, @{$self->{fields}}\)\) || ') p
(0) str
(';) p n
(    $order = \() S
(defined) K
( $self->{order} && scalar @{$self->{order}}\) ? ) p n
(      ') S
( ORDER BY ) str
(' . ) p
(join) K
(\(') p
(,) str
(', map\($_->orderspec, @{$self->{order}}\)\) ) p n
(        : '';) N
(    $limit = \($self->{pagesize} > 0\) ? ) N
(      ') S
( OFFSET ) str
(' . \($self->{page} * $self->{pagesize}\) . ") p
( LIMIT $self->{pagesize}) str
(") p n
() S 8 T (: '';) N
(    $from = ) S
(join) K
(\(') p
( ) str
(', @{$self->{jointext}}\);) p n
(  };) N
(  ) S
(return) K
( $@ ) p
(if) K
( $@;) p n
() N
(  $self->{query} = ") S
(SELECT $select FROM $from WHERE $where$order$limit) str
(";) p n
() N
(  ) S
(return) K
( ) p
(undef) K
(;) p n
(}) N
() N
(# Process a request) c n
(# $results = $xmlout->process\(\);) N
(sub) K
( ) p
(process) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( %args = @_;) p n
(  ) S
(my) K
( $err;) p n
() N
(  $self->{query} ) N
(    ) S
(or) K
( croak ") p
(DBIx::XMLServer::Request: must call parse before process) str
(";) p n
() N
(  $args{rowcount} = $self->{rowcount} ) S
(unless) K
( $args{rowcount};) p n
() N
(  ) S
(# Do the query) c n
(  ) p
(my) K
( $query = $self->{query};) p n
(  $query =~ ) S
(s) K
(/^SELECT/SELECT SQL_CALC_FOUND_ROWS/ ) p n
(    ) S
(if) K
( $args{rowcount} ) p
(eq) K
( ') p
(FOUND_ROWS) str
(';) p n
(  ) S
(my) K
( $sth = $self->{XMLServer}->{dbh}->prepare\($query\);) p n
(  $sth->execute ) S
(or) K
( croak $sth->errstr;) p n
() N
(  ) S
(# Put the data into the result tree) c n
(  ) p
(my) K
( $r = $self->{newrecord}->parentNode;) p n
(  ) S
(my) K
( @row;) p n
(  ) S
(while) K
(\(@row = $sth->fetchrow_array\) {) p n
(XMLServer.pm) (Page 9/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(    ) S
(# Clone the template record and insert after the previous record) c n
(    $r = $r->parentNode->insertAfter\($self->{newrecord}->cloneNode\(1\), $r\);) p n
() N
(    ) S
(# Fill in the values) c n
(    ) p
(my) K
( $p = &$sql_ns\($self->{newrecord}\);) p n
(    ) S
(my) K
( @n = $r->findnodes\(") p
(.//$p:field) str
("\);) p n
(    ) S
(foreach) K
(\(@{$self->{fields}}\) {) p n
(      ) S
(eval) K
( { $_->result\() p
(shift) K
( @n, \\@row\); };) p n
(      ) S
(return) K
( $@ ) p
(if) K
( $@;) p n
(    }) N
() N
(  }) N
() N
(  ) S
(my) K
( $rows = 0;) p n
(  ) S
(do) K
( {) p n
(    ) S
(my) K
( @r;) p n
(    @r = $self->{XMLServer}->{dbh}->selectrow_array\(') S
(SELECT FOUND_ROWS\(\)) str
('\)) p n
(      ) S
(or) K
( croak $self->{XMLServer}->{dbh}->errstr;) p n
(    $rows = $r[0];) N
(  } ) S
(if) K
( $args{rowcount} ) p
(eq) K
( ') p
(FOUND_ROWS) str
(';) p n
(  ) S
(do) K
( {) p n
(    ) S
(my) K
( @r;) p n
(    @r = $self->{XMLServer}->{dbh}->selectrow_array\($self->{count_query}\)) N
(      ) S
(or) K
( croak $self->{XMLServer}->{dbh}->errstr;) p n
(    $rows = $r[0];) N
(  } ) S
(if) K
( $args{rowcount} ) p
(eq) K
( ') p
(COUNT) str
(';) p n
() N
(  ) S
(my) K
( %params = \() p n
(    ') S
(args) str
(' => $self->{arg},) p n
(    ') S
(page) str
(' => $self->{page},) p n
(    ') S
(pagesize) str
(' => $self->{pagesize},) p n
(    ') S
(query) str
(' => $self->{query},) p n
(    ') S
(rows) str
(' => $rows,) p n
(  \);) S 8 T () S 16 T () N
() N
(  ) S
(# Process through XSLT to produce the result) c n
(  ) p
(return) K
( $self->{XMLServer}->{xslt}->transform\($self->{doc}, ) p n
(    XML::LibXSLT::xpath_to_string\(%params\)\);) N
(}) N
() N
(1; ) N
() N
(package) K
( DBIx::XMLServer;) p n
(use) K
( ) p
(Carp) L
(;) p n
() N
(sub) K
( ) p
(add_type) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $type = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $name = $type->getAttribute\(') p
(name) str
('\) ) p n
(    ) S
(or) K
( croak\(") p
(Field type found with no name) str
("\);) p n
(  ) N
(  ) S
(my) K
( $p = &$sql_ns\($type\);) p n
(  ) S
(my) K
( $package_name = $type->findnodes\(") p
($p:module) str
("\);) p n
(  ) S
(if) K
(\($package_name->size\) {) p n
(    $package_name = ") S
($package_name) str
(";) p n
(    ) S
(eval) K
( ") p
(use $package_name;) str
(";) p n
(    croak ") S
(Error loading module `$package_name' for field type) str
(") p n
(      . ") S
( definition `$name':\\n$@) str
(" ) p
(if) K
( $@;) p n
(  } ) S
(else) K
( {) p n
(    $package_name = ") S
(DBIx::XMLServer::Types::$name) str
(";) p n
(    ) S
(my) K
( $where = $type->findnodes\(") p
($p:where) str
("\);) p n
(    $where = $where->size ? ") S
(sub where { $where }) str
(" : '';) p n
(    ) S
(my) K
( $select = $type->findnodes\(") p
($p:select) str
("\);) p n
(    $select = $select->size ? ") S
(sub select { $select }) str
(" : '';) p n
(    ) S
(my) K
( $join = $type->findnodes\(") p
($p:join) str
("\);) p n
(    $join = $join->size ? ") S
(sub join { $join }) str
(" : '';) p n
(    ) S
(my) K
( $value = $type->findnodes\(") p
($p:value) str
("\);) p n
(    $value = $value->size ? ") S
(sub value { $value }) str
(" : '';) p n
(XMLServer.pm) (Page 10/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (5/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (11-12) 6
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    ) p
(my) K
( $init = $type->findnodes\(") p
($p:init) str
("\);) p n
(    $init = $init->size ? ") S
(sub init { $init }) str
(" : '';) p n
(    ) S
(my) K
( $isa = $type->findnodes\(") p
($p:isa) str
("\);) p n
(    $isa = $isa->size ? ") S
($isa) str
(" : ') p
(DBIx::XMLServer::Field) str
(';) p n
(    $isa =~ ) S
(s) K
(/\\s+//g;) p n
(    ) S
(eval) K
( <<EOF;) p n
(package) K
( $package_name;) p n
(use) K
( ) p
(XML::LibXML) L
(;) p n
(our \\@ISA = \(') S
($isa) str
('\);) p n
($init) N
($select) N
($where) N
($join) N
($value) N
(1;) N
(EOF) N
(    croak ") S
(Error compiling field type definition `$name':\\n$@) str
(" ) p
(if) K
( $@;) p n
(  }) N
(  $self->{types}->{$name} = $package_name;) N
(}) N
() N
(# Object constructor) c n
(# $xmlout = new DBIx::XMLServer\($dbh, $doc[, $template]\);) N
(sub) K
( ) p
(new) L
( {) p n
(  ) S
(my) K
( $proto = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $class = ) p
(ref) K
(\($proto\) || $proto;) p n
(  ) S
(my) K
( $self;) p n
(  ) S
(my) K
( $doc;) p n
() N
(  ) S
(# Deal with the parameters) c n
(  ) p
(if) K
(\() p
(ref) K
( $_[0]\) { ) p
(# dbh, doc [, template]) c n
(    $self = {};) p n
(    $self->{dbh} = ) S
(shift) K
( ) p
(or) K
( croak ") p
(No database handle supplied) str
(";) p n
(    $doc = ) S
(shift) K
( ) p
(or) K
( croak ") p
(No template file supplied) str
(";) p n
(    $self->{template} = ) S
(shift) K
(;) p n
(  } ) S
(else) K
( { ) p
(# Named parameters) c n
(    $self = { @_ };) p n
(    $self->{dbh} ) S
(or) K
( croak ") p
(No database handle supplied) str
(";) p n
(    $doc = $self->{doc} ) S
(or) K
( croak ") p
(No template file supplied) str
(";) p n
(  }) N
(  ) S
(bless) K
(\($self, $class\);) p n
() N
(  ) S
(my) K
( $parser = new XML::LibXML;) p n
(  ) S
(ref) K
( $doc ) p
(or) K
( $doc = $parser->parse_file\($doc\)) p n
(    ) S
(or) K
( croak ") p
(Couldn't parse template file '$doc') str
(";) p n
(  $doc->isa\(') S
(XML::LibXML::Document) str
('\)) p n
(    ) S
(or) K
( croak ") p
(This isn't a XML::LibXML::Document) str
(";) p n
(  $self->{doc} = $doc;) N
() N
(  ) S
(my) K
( $root = $doc->documentElement;) p n
(  $root->localname ) S
(eq) K
( ') p
(spec) str
(' && $root->namespaceURI ) p
(eq) K
( $our_ns) p n
(    ) S
(or) K
( croak ") p
(Document element is not <sql:spec>) str
(";) p n
() N
(  ) S
(my) K
( $p = &$sql_ns\($root\);) p n
() N
(  ) S
(# Find all the field type definitions and parse them) c n
(  $self->{types} = {};) p n
(  ) S
(foreach) K
(\($doc->findnodes\(") p
(/$p:spec/$p:type) str
("\)\) {) p n
(    $self->add_type\($_\);) N
(  }) N
() N
(  ) S
(# Find the template) c n
(  $self->{template}) p n
(    ) S
(or) K
( $self->{template} = $doc->find\(") p
(/$p:spec/$p:template) str
("\)) p n
(        ->) S
(shift) K n
(      ) p
(or) K
( croak ") p
(No <sql:template> element found) str
(";) p n
() N
(  $self->{template}->isa\(') S
(XML::LibXML::Element) str
('\)) p n
(    ) S
(or) K
( croak ") p
(Template is not a XML::LibXML::Element) str
(";) p n
(XMLServer.pm) (Page 11/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(  $self->{template}->localname ) S
(eq) K
( ') p
(template) str
(') p n
(    && $self->{template}->namespaceURI ) S
(eq) K
( $our_ns) p n
(      ) S
(or) K
( croak ") p
(Template is not <sql:template>) str
(";) p n
() N
(  ) S
(# Parse our XSLT stylesheet) c n
(  ) p
(my) K
( $xslt = new XML::LibXSLT;) p n
(  ) S
(my) K
( $f = $INC{') p
(DBIx/XMLServer.pm) str
('};) p n
(  $f =~ ) S
(s) K
(/XMLServer\\.pm/XMLServer\\/xmlout\\.xsl/;) p n
(  ) S
(my) K
( $style_doc = $parser->parse_file\($f\)) p n
(    ) S
(or) K
( croak ") p
(Couldn't open stylesheet '$f') str
(";) p n
(  $self->{xslt} = $xslt->parse_stylesheet\($style_doc\)) N
(    ) S
(or) K
( croak ") p
(Error parsing stylesheet '$f') str
(";) p n
() N
(  $self->{maxpagesize} = 0 ) S
(unless) K
( $self->{maxpagesize};) p n
(  $self->{rowcount} = ') S
(NONE) str
(' ) p
(unless) K
( ) p
(defined) K
( $self->{rowcount};) p n
() N
(  ) S
(return) K
( $self;) p n
(}) N
() N
(sub) K
( ) p
(process) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( %args;) p n
(  ) S
(my) K
( $err;) p n
() N
(  ) S
(# Process arguments) c n
(  ) p
(if) K
(\($#_ <= 1 && $_[0] ) p
(ne) K
( ') p
(query) str
('\) {) p n
(    $args{query} = ) S
(shift) K n
(      ) p
(or) K
( croak ") p
(No query string given) str
(";) p n
(  } ) S
(else) K
( { ) p
(# Named parameters) c n
(    %args = @_;) p n
(  }) N
() N
(  $args{XMLServer} = $self;) N
(  ) S
(my) K
( $request = new DBIx::XMLServer::Request\(%args\);) p n
(  $err = $request->parse\($args{query}\) ) S
(and) K
( ) p
(return) K
( $err;) p n
(  ) S
(return) K
( $request->process\(\);) p n
(}) N
() N
(1;) N
(__END__) N
() N
(=head1 NAME) C n
() N
(DBIx::XMLServer - Serve data as XML in response to HTTP requests) N
() N
(=head1 SYNOPSIS) N
() N
(  use XML::LibXML;) N
(  use DBIx::XMLServer;) N
() N
(  my $xml_server = new DBIx::XMLServer\($dbh, "template.xml"\);) N
() N
(  my $doc = $xml_server->process\($QUERY_STRING\);) N
(  die "Error: $doc" unless ref $doc;) N
() N
(  print "Content-type: application/xml\\r\\n\\r\\n";) N
(  print $doc->toString\(1\);) N
() N
(=head1 DESCRIPTION) N
() N
(This module implements the whole process of generating an XML document) N
(from a database query, in response to an HTTP request.  The mapping) N
(from the DBI database to an XML structure is defined in a template) N
(file, also in XML; this template is used not only to turn the data) N
(into XML, but also to parse the query string.  To the user, the format) N
(of the query string is very natural in relation to the XML data which) N
(they will receive.) N
() N
(XMLServer.pm) (Page 12/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (6/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (13-14) 7
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(All the methods of this object can take a hash of named parameters instead) C n
(of a list of parameters.) N
() N
(One C<DBIx::XMLServer> object can process several queries.  The) N
(following steps take place in processing a query:) N
() N
(=over) N
() N
(=item 1.) N
() N
(The query string is parsed.  It contains search criteria together with) N
(other options about the format of the returned data.) N
() N
(=item 2.) N
() N
(The search criteria from the query string are converted, using the XML) N
(template, into an SQL SELECT statement.) N
() N
(=item 3.) N
() N
(The results of the SQL query are translated into XML, again using the) N
(template, and returned to the caller.) N
() N
(=back) N
() N
(=head1 METHODS) N
() N
(=head2 Constructor) N
() N
(  my $xml_server = new DBIx::XMLServer\( $dbh, $template_doc ) N
(                                        [, $template_node] \);) N
() N
(  my $xml_server = new DBIx::XMLServer\( dbh => $dbh,) N
(                                        doc => $template_doc,) N
(                                        template => $template_node,) N
(                                        maxpagesize => $maxpagesize \);) N
() N
(The constructor for C<DBIx::XMLServer> takes two mandatory arguments) N
(and two optional arguments.) N
() N
(=over) N
() N
(=item C<$dbh>) N
() N
(This is a handle for the database; see L<DBI> for more information.) N
() N
(=item C<$template_doc>) N
() N
(This is the XML document containing the template.  It may be either an) N
(C<XML::LibXML::Document> object or a string, which is taken as a file) N
(name.) N
() N
(=item C<$template_node>) N
() N
(One template file may contain several individual templates; if so,) N
(this argument may be used to pass an C<XML::LibXML::Element> object) N
(indicating which template should be used.  By default the first) N
(template in the file is used.) N
() N
(=item C<$maxpagesize>) N
() N
(This option may be used to limit the number of records than will be) N
(returned in a query.  The user can choose a page size smaller than) N
(this by using the C<pagesize> option on their query \(see below\), but ) N
(they will not be allowed to request a page size larger than this ) N
(maximum.) N
() N
(=back) N
() N
(XMLServer.pm) (Page 13/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(=head2 process\(\)) C n
() N
(  my $result = $xml_server->process\( $query [, $template_node] \);) N
() N
(  my $result = $xml_server->process\( query => $query,) N
(                                     template => $template_node,) N
(                                     rowcount => $rowcount,) N
(                                     userformat => $userformat \);) N
() N
(This method processes an HTTP query and returns an XML document) N
(containing the results of the query.  There are one mandatory argument) N
(and two optional arguments.) N
() N
(=over) N
() N
(=item C<$query>) N
() N
(This is the HTTP GET query string to be processed.) N
() N
(=item C<$template_node>) N
() N
(As above, this may indicate which of several templates is to be used) N
(for this query.  It is an C<XML::LibXML::Element> object.) N
() N
(=item C<$rowcount>) N
() N
(It is possible to limit the number of rows returned in one query, either) N
(in response to a user request \(by using the C<pagesize> option, see below\)) N
(or by passing the C<maxpagesize> option when creating the C<DBIx::XMLServer>) N
(object.  In these cases it may be useful to know the total number of rows ) N
(that would have been returned had no limit been in place.  The number of) N
(rows can be put into the output XML document using the) N
(B<< <sql:meta type="rows"> >> element in the template \(see below\).  This) N
(argument chooses how this information should be obtained from the database.) N
() N
(=over) N
() N
(=item FOUND_ROWS) N
() N
(Passing C<< rowcount => 'FOUND_ROWS' >> tells the module to use the) N
(B<SQL_COUNT_FOUND_ROWS> option and the B<FOUND_ROWS> function.  If) N
(your database supports these, use this option.) N
() N
(=item COUNT) N
() N
(Passing C<< rowcount => 'COUNT' >> means that a second query will be) N
(done after the main database query, of this form:) N
() N
(  SELECT COUNT\(*\) FROM ... WHERE ...) N
() N
(=back) N
() N
(=item C<$userformat>) N
() N
(Setting this to a true value allows the user to choose between several) N
(templates in the file by specifying the C<format> option in the query) N
(string.) N
() N
(=back) N
() N
(The return value of this method is either an C<XML::LibXML::Document>) N
(object containing the result, or a string containing an error message.) N
(An error string is only returned for errors caused by the HTTP query) N
(string and thus the user's fault; other errors, which are the) N
(programmer's fault, will B<croak>.) N
() N
(=head1 EXAMPLE) N
() N
(This example is taken from the tests included with the module.  The) N
(XMLServer.pm) (Page 14/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (7/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (15-16) 8
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(database contains two tables.) C n
() N
(  Table dbixtest1:) N
() N
(  +----+--------------+---------+------+) N
(  | id | name         | manager | dept |) N
(  +----+--------------+---------+------+) N
(  |  1 | John Smith   |    NULL |    1 |) N
(  |  2 | Fred Bloggs  |       3 |    1 |) N
(  |  3 | Ann Other    |       1 |    1 |) N
(  |  4 | Minnie Mouse |    NULL |    2 |) N
(  |  5 | Mickey Mouse |       4 |    2 |) N
(  +----+--------------+---------+------+) N
() N
(  Table dbixtest2:) N
() N
(  +----+----------------------+) N
(  | id | name                 |) N
(  +----+----------------------+) N
(  |  1 | Widget Manufacturing |) N
(  |  2 | Widget Marketing     |) N
(  +----+----------------------+) N
() N
(The template file \(in F<t/t10.xml>\) contains the following three table) N
(definitions:) N
() N
(  <sql:table name="employees" sqlname="dbixtest1"/>) N
(  <sql:table name="managers" sqlname="dbixtest1") N
(    join="left" jointo="employees" refcolumn="manager" keycolumn="id"/>) N
(  <sql:table name="departments" sqlname="dbixtest2") N
(    join="left" jointo="employees" refcolumn="dept" keycolumn="id"/>) N
() N
(The template element is as follows:) N
() N
(  <sql:template table="employees">) N
(    <employees>) N
(      <sql:record>) N
() S 8 T (<employee id="foo">) N
() S 8 T (  <sql:field type="number" attribute="id" expr="employees.id"/>) N
() S 8 T (  <name>) N
() S 8 T (    <sql:field type="text" expr="employees.name"/>) N
() S 8 T (  </name>) N
() S 8 T (  <manager>) N
() S 8 T (    <sql:field type="text" expr="managers.name" join="managers") N
(              null='nil'/>) N
() S 8 T (  </manager>) N
(          <department>) N
() S 8 T (    <sql:field type="text" expr="departments.name" join="departments"/>) N
() S 8 T (  </department>) N
() S 8 T (</employee>) N
(      </sql:record>) N
(    </employees>) N
(  </sql:template>) N
() N
(The query string B<name=Ann*> produces the following output:) N
() N
(  <?xml version="1.0"?>) N
(  <employees>) N
(    <employee id="3">) N
(      <name>Ann Other</name>) N
(      <manager>John Smith</manager>) N
(      <department>Widget Manufacturing</department>) N
(    </employee>) N
(  </employees>) N
() N
(The query string B<department=Widget%20Marketing&fields=name> produces) N
(the following output:) N
() N
(  <?xml version="1.0"?>) N
(XMLServer.pm) (Page 15/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  <employees>) C n
(    <employee id="4">) N
(      <name>Minnie Mouse</name>) N
(    </employee>) N
(    <employee id="5">) N
(      <name>Mickey Mouse</name>) N
(    </employee>) N
(  </employees>) N
() N
(=head1 HOW IT WORKS: OVERVIEW) N
() N
(The main part of the template file which controls DBIx::XMLServer is) N
(the template element.  This element gives a skeleton for the output) N
(XML document.  Within the template element is an element, the record) N
(element, which gives a skeleton for that part of the document which is) N
(to be repeated for each row in the SQL query result.  The record element) N
(is a fragment of XML, mostly not in the B<sql:> namespace, which contains) N
(some B<< <sql:field> >> elements.) N
() N
(Each B<< <sql:field> >> element corresponds to a point in the record) N
(element where data from the database will be inserted.  Often, this) N
(means that one B<< <sql:field> >> element corresponds to one column in) N
(a table in the database.  The field has a I<type>; this determines the) N
(mappings both between data in the database and data in the XML) N
(document, and between the user's HTTP query string and the SQL WHERE) N
(clause.) N
() N
(The HTTP query which the user supplies consists of search criteria,) N
(together with other special options which control the format of the) N
(XML output document.  Each criterion in the HTTP query selects one) N
(field in the record and gives some way of limiting data on that field,) N
(typically by some comparison operation.  The selection of the field is) N
(accomplished by an XPath expression, normally very simply consisting) N
(just of the name of the field.  After the field has been selected, the) N
(remainder of the criterion is processed by the Perl object) N
(corresponding to that field type.  For example, the built-in text) N
(field type recognises simple string comparisons as well as regular) N
(expression comparisons; and the build-in number field type recognises) N
(numeric comparisons.) N
() N
(All these criteria are put together to form the WHERE clause of the) N
(SQL query.  The user may also use the special B<fields=...> option to) N
(select which fields appear in the resulting XML document; the value of) N
(this option is again an XPath expression which selects a part of the) N
(record template to be returned.) N
() N
(Other special options control how many records are returned on each) N
(page, which page of the results should be returned, and may choose one) N
(of several templates in the file.) N
() N
(The template to use for a query is chosen as follows:) N
() N
(=over) N
() N
(=item 1.) N
() N
(If the B<userformat> option is set when calling C<DBIx::XMLServer::process\(\)>) N
(and the user has chosen a template with the B<format> option in the query) N
(string, that template is used.) N
() N
(=item 2.) N
() N
(Otherwise, if a template was specified when calling ) N
(C<DBIx::XMLServer::process\(\)>, then that template is used.) N
() N
(=item 3.) N
() N
(Otherwise, if a template was specified when constructing the ) N
(C<DBIx::XMLServer> object, then that template is used.) N
(XMLServer.pm) (Page 16/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (8/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (17-18) 9
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() C n
(=item 4.) N
() N
(Otherwise, the first template in the file is used.) N
() N
(=back) N
() N
(=head1 THE TEMPLATE FILE) N
() N
(The behaviour of DBIx::XMLServer is determined entirely by the) N
(template file, which is an XML document.  This section explains the) N
(format and meaning of the various elements which can occur in the) N
(template file.) N
() N
(=head2 Namespace) N
() N
(All the special elements used in the template file are in the) N
(namespace associated to the URI B<http://boojum.org.uk/NS/XMLServer>.) N
(In this section we will suppose that the prefix B<sql:> is bound to) N
(that namespace, though of course any other prefix could be used) N
(instead.) N
() N
(=head2 The root element) N
() N
(The document element of the template file must be an B<< <sql:spec> >>) N
(element.  This element serves only to contain the other elements in) N
(the template file.) N
() N
(Contained in the root element are elements of three types:) N
() N
(=over) N
() N
(=item *) N
() N
(Field type definition elements;) N
() N
(=item *) N
() N
(Table definition elements;) N
() N
(=item *) N
() N
(One or more template elements.) N
() N
(=back) N
() N
(We now describe each of these in more detail.) N
() N
(=head2 Field type definitions) N
() N
(A field type definition is given by a B<< <sql:type> >> element.  Each) N
(field in the template has a type.  That type determines: how a) N
(criterion from the query string is converted to an SQL WHERE clause) N
(for that field; how the SQL SELECT clause to retrieve data for that) N
(field is created; and how the resulting SQL data is turned into XML.) N
(For example, the standard date field type can interpret simple date) N
(comparisons in the query string, and puts the date into a specific) N
(format in the XML.) N
() N
(Each field type is represented by a Perl object class, derived from) N
(C<DBIx::XMLServer::Field>.  For information about the methods which) N
(this class must define, see L<DBIx::XMLServer::Field>.  The class may) N
(be defined in a separate Perl module file, as for the standard field) N
(types; or the methods of the class may be included verbatim in the XML) N
(file, as follows.) N
() N
(The B<< <sql:type> >> element has one attribute, B<name>, and four) N
(element which may appear as children.) N
() N
(XMLServer.pm) (Page 17/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(=over) C n
() N
(=item attribute: B<name>) N
() N
(The B<name> attribute defines the name by which this type will be) N
(referred to in the templates.) N
() N
(=item element: B<< <sql:module> >>) N
() N
(If the Perl code implementing the field type is contained in a Perl) N
(module in a separate file, this element is used to give the name) N
(of the module.  It should contain the Perl name of the module \(for) N
(example, C<DBIx::XMLServer::NumberField>\).) N
() N
(=back) N
() N
(=head3 Example) N
() N
(  <sql:type name="number">) N
(    <sql:module>DBIx::XMLOut::NumberField</sql:module>) N
(  </sql:type>) N
() N
(Instead of the B<< <sql:module> >> element, the B<< <sql:type> >>) N
(element may have separate child elements defining the various facets) N
(of the field type.) N
() N
(=over) N
() N
(=item element: B<< <sql:isa> >>) N
() N
(This element contains the name of a Perl module from which the field) N
(type is derived.  The default is C<DBIx::XMLServer::Field>.) N
() N
(=item element: B<< <sql:select> >>) N
() N
(This element contains the body of the C<select> method \(probably) N
(inside a CDATA section\).) N
() N
(=item element: B<< <sql:where> >>) N
() N
(This element contains the body of the C<where> method \(probably inside) N
(a CDATA section\).) N
() N
(=item element: B<< <sql:join> >>) N
() N
(This element contains the body of the C<join> method \(probably inside) N
(a CDATA section\).) N
() N
(=item element: B<< <sql:value> >>) N
() N
(This element contains the body of the C<value> method \(probably inside) N
(a CDATA section\).) N
() N
(=item element: B<< <sql:init> >>) N
() N
(This element contains the body of the C<init> method \(probably inside) N
(a CDATA section\).) N
() N
(=back) N
() N
(=head2 Table definitions) N
() N
(Any SQL table which will be accessed by the template needs a table) N
(definition.  As a minimum, a table definition associates a local name) N
(for a table with the table's SQL name.  In addition, the definition) N
(can specify how this table is to be joined to the other tables in the) N
(database.) N
() N
(Note that one SQL table may often be joined several times in different) N
(XMLServer.pm) (Page 18/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (9/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (19-20) 10
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(ways; this can be accomplished by several table definitions, all) C n
(referring to the same SQL table.) N
() N
(A table definition is represented by the B<< <sql:table> >> element,) N
(which has no content but several attributes.) N
() N
(=over) N
() N
(=item attribute: B<name>) N
() N
(This mandatory attribute gives the name by which the table will be) N
(referred to in the template, and also the alias by which it will be) N
(known in the SQL statement.) N
() N
(=item attribute: B<sqlname>) N
() N
(This mandatory attribute gives the SQL name of the table.  In the) N
(SELECT statement, the table will be referenced as <sqlname> AS <name>.) N
() N
(=item attribute: B<jointo>) N
() N
(This attribute specifies the name of another table to which this table) N
(is joined.  Whenever a query involves a column from this table, this) N
(and the following attributes will be used to add an appropriate join) N
(to the SQL SELECT statement.) N
() N
(=item attribute: B<join>) N
() N
(This attribute specifies the type of join, such as B<LEFT>, B<RIGHT>,) N
(B<INNER> or B<OUTER>.) N
() N
(=item attribute: B<on>) N
() N
(This attribute specifies the ON clause used to join the two tables.  In) N
(the most common case, the following two attributes may be used instead.) N
() N
(=item attribute: B<keycolumn>) N
() N
(This attribute gives the column in this table used to join to the other ) N
(table.) N
() N
(=item attribute: B<refcolumn>) N
() N
(This attribute gives the column in the other table used for the join.) N
(Specifying B<keycolumn> and B<refcolumn> is equivalent to giving the) N
(B<on> attribute value) N
() N
(  <this table's name>.<keycolumn> = <other table's name>.<refcolumn> .) N
() N
(=back) N
() N
(=head2 The template element) N
() N
(A template file must contain at least one B<< <sql:template> >>) N
(element.  This element defines the shape of the output document.  It) N
(may contain arbitrary XML elements, which are copied straight to the) N
(output document.  It also contains one B<< <sql:record> >> element,) N
(which defines that part of the output document which is repeated for) N
(each row returned from the SQL query.) N
() N
(Further, the template element may contain B<< <sql:meta> >> elements) N
(which indicate that certain information about the query should be) N
(inserted into the output document.) N
() N
(As the output document is formed from the content of the B<<) N
(<sql:template> >> element, it follows that this element must have) N
(exactly one child element.) N
() N
(The B<< <sql:template> >> may have the following attributes:) N
(XMLServer.pm) (Page 19/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() C n
(=over) N
() N
(=item attribute: B<id>) N
() N
(This optional attribute gives a unique identifier to the template.  The) N
(user may, if allowed, choose which template to use by specifying the) N
(B<format> option in the query string together with this identifier.) N
() N
(=item attribute: B<table>) N
() N
(This mandatory attribute specifies the main table for this template, to) N
(which any other tables will be joined.) N
() N
(=item attribute: B<default-namespace>) N
() N
(In the HTTP query string, the user must refer to parts of the template.) N
(To avoid them having to specify namespaces for these, this attribute) N
(gives a default namespace which will be used for unqualified names) N
(in the query string.) N
() N
(=back) N
() N
(=head2 The record element) N
() N
(Each template contains precisely one B<< <sql:record> >> element among) N
(its descendants.  This record element defines that part of the output) N
(XML document which is to be repeated once for each row in the result) N
(of the SQL query.  The content of the record element consists of a) N
(fragment of XML containing some B<< <sql:field> >> elements; each of) N
(these defines a point at which SQL data will be inserted into the) N
(record.  The B<< <sql:record> >> must have precisely one child element.) N
() N
(It is also to the structure inside the B<< <sql:record> >> element) N
(that the user's HTTP query refers.) N
() N
(The B<< <sql:record> >> element has no attributes.) N
() N
(=head2 The field element) N
() N
(The record element will contain several B<< <sql:field> >> elements.) N
(Each of these field elements defines what the user will think of as a) N
(B<field>; that is, a part of the XML record which changes from one) N
(record to the next.  Normally this will correspond to one column in an) N
(SQL table, though this is not obligatory.) N
() N
(A field has a B<type>, which refers to one of the field type) N
(definitions in the template file.  This type determines the mappings) N
(both between SQL data and XML output data, and between the user's) N
(query and the SQL WHERE clause.) N
() N
(The B<< <sql:field> >> element may have the following attributes:) N
() N
(=over) N
() N
(=item attribute: B<type>) N
() N
(This mandatory attribute gives the type of the field.  It is the name) N
(of one of the field types defined in the template file.) N
() N
(=item attribute: B<join>) N
() N
(This attribute specifies which table needs to be joined to the main) N
(table in order for this field to be found.  \(Note: this attribute is) N
(only read by the field type class's C<join> method.  If that method is) N
(overridden, this attribute may become irrelevant.\)) N
() N
(=item attribute: B<attribute>) N
() N
(XMLServer.pm) (Page 20/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (10/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (21-22) 11
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(If this attribute is set, the contents of the field will not be) C n
(returned as a text node, but rather as an attribute on the B<<) N
(<sql:field> >> node's parent node.  The value of the B<attribute>) N
(attribute gives the name of the attribute on the parent node which) N
(should be filled in with the value of this field.  When this attribute) N
(is set, the parent node should always have an attribute of that name) N
(defined; the contents are irrelevant.) N
() N
(=item attribute: B<expr>) N
() N
(This attribute gives the SQL SELECT expression which should be) N
(evaluated to find the value of the field.  \(Note: this attribute is) N
(only ever looked at in the field type class's C<select> method.  If) N
(this method is overridden, this attribute need not necessarily still) N
(be present.\)) N
() N
(=item attribute: B<null>) N
() N
(This attribute determines the action when the field value is null.  There) N
(are three possible values:) N
() N
(=over) N
() N
(=item B<empty> \(default\)) N
() N
(The field is omitted from the result, but the parent element remains.) N
() N
(=item B<omit>) N
() N
(The parent element is omitted from the record) N
() N
(=item B<nil>) N
() N
(The parent element has the B<xsi:nil> attribute set.) N
() N
(=back) N
() N
(=back) N
() N
(=head2 The sql:omit attribute) N
() N
(Any element in the record may have the Boolean attribute B<sql:omit>.) N
(If this attribute is set, then this element will be omitted from any) N
(record in which the element is empty \(because child elements have been) N
(omitted\).) N
() N
(=head2 The meta element) N
() N
(The B<< <sql:meta> >> element is used for putting information about the) N
(query into the output document.  The information is selected by the) N
(B<type> attribute of the element.  The following B<type> attributes) N
(are recognised:) N
() N
(=over) N
() N
(=item type='args') N
() N
(This gives the original query string passed to B<DBIx::XMLServer>.) N
() N
(=item type='page') N
() N
(This gives the page number within the results, as selected by the) N
(B<page=> option in the query string.) N
() N
(=item type='pagesize') N
() N
(This gives the page size, as selected by the B<pagesize=> option in ) N
(the query string.) N
() N
(XMLServer.pm) (Page 21/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(=item type='query') C n
() N
(This gives the SQL query which was executed to produce the results.) N
() N
(=item type='rows') N
() N
(This gives the number of rows which the query would have returned, had) N
(it not been for the B<page=> and B<pagesize=> options.  To tell the) N
(module how to find this information, set the B<rowcount> option when) N
(processing the request \(see above\).) N
() N
(=back) N
() N
(The B<< <sql:meta> >> element in the template will be replaced by the) N
(corresponding string in the output document.  Alternatively, it is) N
(possible to place the string into the output document as an attribute) N
(to the parent element of the B<< <sql:meta> >> element.  To do this,) N
(include an attribute B<attribute="name"> on the B<< <sql:meta> >> element,) N
(where B<name> is the local name of the attribute.  To add a namespace) N
(to the attribute, additionally include an attribute B<namespace="foo">) N
(on the B<< <sql:meta> >> element, replacing B<foo> with whatever) N
(namespace should be used.) N
() N
(=head1 SPECIAL OPTIONS IN THE QUERY STRING) N
() N
(The HTTP query string may contain certain special options which are) N
(not interpreted as criteria on the records to be returned, but instead) N
(have some other effect.) N
() N
(=over) N
() N
(=item fields = <expression>) N
() N
(This option selects which part of each record is to be returned.  In) N
(the absence of this option, an entire record is returned for each row) N
(in the result of the SQL query.  If this option is set, its value) N
(should be an XPath expression.  The expression will be evaluated in) N
(the context of the single child of the B<< <sql:record> >> element and) N
(should evaluate to a set of nodes; the part of the record returned is) N
(the smallest subtree containing all the nodes selected by the) N
(expression.) N
() N
(=item pagesize = <number>, page = <number>) N
() N
(These options give control over how many records are returned in one) N
(query, and which of several pages is returned.  To put a limit on the) N
(page size which can be requested, use the B<maxpagesize> option when) N
(creating the C<DBIx::XMLServer> object.  By default there is no limit.) N
() N
(=item order = <list>) N
() N
(This option controls how records are ordered in the output document.) N
(The B<< <list> >> should be a comma-separated list of XPath) N
(expressions, each optionally followed by a space and the string) N
(B<ascending> or B<descending>.  Each of these XPath expressions is) N
(evaluated within the context of the single child of the ) N
(B<< <sql:record> >> element and should select one or more fields;) N
(these fields are used to order the result records.  Fields are used in) N
(the order that they appear in the list; if a single list element) N
(selects more than one field, they are used in document order.) N
() N
(=back) N
() N
(=head1 HOW IT REALLY WORKS) N
() N
(When a C<DBIx::XMLServer> object is created, the template file is) N
(parsed.  A new Perl module is compiled for each field type defined.) N
() N
(The C<process\(\)> method performs the following steps.) N
(XMLServer.pm) (Page 22/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (11/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (23-24) 12
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() C n
(=over) N
() N
(=item 1.) N
() N
(The HTTP query string is parsed.  It is split at each `&' character,) N
(and each resulting fragment is un-URL-escaped.  Each fragment is then) N
(examined, and a leading part removed which matches a grammar very) N
(similar to the B<Pattern> production in XSLT \(see) N
(L<http://www.w3.org/TR/xslt>\).  This leading part is assumed to be an) N
(expression referring to a field in the B<< <sql:record> >> element of) N
(the template, unless it is one of the special options B<fields>,) N
(B<pagesize> or B<page>.  If the B<< <sql:template> >> has a) N
(B<default-namespace> attribute, then any unqualified name in this) N
(expression has that default namespace added to it.) N
() N
(=item 2.) N
() N
(Each criterion in the query string is turned into part of the WHERE) N
(clause.  The leading part of each fragment of the query string is) N
(evaluated as an XPath expression in the context of the single child of) N
(the B<< <sql:record> >> element.  The result must be either a nodeset) N
(having a unique B<< <sql:field> >> descendant; or an attribute on an) N
(element having a child B<< <sql:field> >> element whose B<attribute>) N
(attribute matches.  In either case, a single B<< <sql:field> >>) N
(element is found.  That field's type is looked up and the resulting) N
(field type class's C<where> method called, being passed the remainder) N
(of the fragment of the HTTP query string.  The result of the C<where>) N
(method is added to the WHERE clause; all criteria are combined by AND.) N
() N
(=item 3.) N
() N
(A new result document is created whose document element is a clone of) N
(the B<< <sql:template> >> element.  The B<< <sql:record> >> in this) N
(new document is located.  The value of the special B<fields> option is) N
(evaluated, as an XPath expression, within the unique child of that) N
(element, and the smallest subtree containing the resulting fields is) N
(formed.  The rest of the record is pruned away.  The SQL SELECT clause) N
(is now created by calling the C<select> method of each of the B<<) N
(<sql:field> >> elements left after this pruning.) N
() N
(=item 4.) N
() N
(The `tables' part of the SELECT statement is formed by calling the) N
(C<join> methods of all the tables which are referred to either in the) N
(search criteria, or by any of the field to be returned.) N
() N
(=item 5.) N
() N
(The SELECT statement is executed.  For each result row, a copy of the) N
(pruned result record is created.  Each field in this record is filled in) N
(by calling the C<value> method of the corresponding field type.) N
() N
(=item 6.) N
() N
(The resulting document is passed through an XSL transform for tidying) N
(up before being returned to the caller.) N
() N
(=back) N
() N
(=head1 BUGS) N
() N
(There are quite a lot of stray namespace declarations in the output.) N
(They make no difference to the semantic meaning of the markup, but) N
(they are ugly.  I gather that XML::LibXML will provide the means to) N
(remove them in the near future.) N
() N
(The way we build JOIN expressions isn't very clever, and probably) N
(doesn't work for anything more than the simplest situations.) N
(XMLServer.pm) (Page 23/24) (Sep 09, 09 15:14) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() C n
(The way we add a default prefix to every XPath expression is a bit of) N
(a hack.  I think the only way to fix this is to wait for XPath 2.0 to) N
(be widely available.) N
() N
(This module has been written to use MySQL and has only been tested on) N
(that platform.  I would be interested to hear from users who have been) N
(able to make it work on other platforms.) N
() N
(=head1 SEE ALSO) N
() N
(L<DBIx::XMLServer::Field>) N
() N
(=head1 AUTHOR) N
() N
(Martin Bright E<lt>martin@boojum.org.ukE<gt>) N
() N
(=head1 COPYRIGHT AND LICENCE) N
() N
(Copyright \(C\) 2003-4 Martin Bright) N
() N
(This library is free software; you can redistribute it and/or modify) N
(it under the same terms as Perl itself.) N
() N
(=cut) N
(XMLServer.pm) (Page 24/24) (Sep 09, 09 15:14) title
border
grestore
(Printed by Michiel van Loon) rhead
(XMLServer.pm) (12/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 13
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(# $Id: BooleanField.pm,v 1.5 2005/05/26 15:01:03 mjb47 Exp $) c n
() p n
(package) K
( DBIx::XMLServer::BooleanField;) p n
(use) K
( ) p
(XML::LibXML) L
(;) p n
(our @ISA = \(') S
(DBIx::XMLServer::Field) str
('\);) p n
() N
(=head1 NAME) C n
() N
(DBIx::XMLServer::BooleanField - Boolean field type) N
() N
(=head1 DESCRIPTION) N
() N
(This class implements the built-in Boolean field type of) N
(DBIx::XMLServer.  The B<where> and B<value> methods are overridden) N
(from the base class.) N
() N
(=head2 B<where> method) N
() N
(  $sql_expression = $boolean_field->where\($condition\);) N
() N
(The condition must either be empty, or be equal to one of the following:) N
() N
(  !) N
(  =1) N
(  =y) N
(  =yes) N
(  =true) N
(  =0) N
(  =n) N
(  =no) N
(  =false .) N
() N
(If the condition is empty, then the SQL expression is) N
() N
(  <field> IS NOT NULL .) N
() N
(If the condition is the character '!', then the SQL expression is) N
() N
(  <field> IS NULL .) N
() N
(Otherwise, the SQL expression returned is equal to) N
() N
(  <field> = 'Y'  or  <field> = 'N') N
() N
(accordingly.) N
() N
(=cut) N
() p n
(sub) K
( ) p
(where) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $cond = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $column = $self->) p
(select) K
(;) p n
(  ) S
(return) K
( ") p
($column IS NOT NULL) str
(" ) p
(if) K
( $cond ) p
(eq) K
( '';) p n
(  ) S
(return) K
( ") p
($column IS NULL) str
(" ) p
(if) K
( $cond ) p
(eq) K
( ') p
(!) str
(';) p n
(  $cond ) S
(or) K
( ) p
(return) K
( ") p
($column = 'Y') str
(";) p n
(  $cond =~ ) S
(s) K
(/^=// ) p
(or) K
( ) p
(die) K
( ") p
(Unrecognised Boolean condition: $cond) str
(";) p n
(  $cond =~ /^\(1|y\(es\)?|true\)$/i && ) S
(return) K
( ") p
($column = 'Y') str
(";) p n
(  $cond =~ /^\(0|n\(o\)?|false\)$/i && ) S
(return) K
( ") p
($column = 'N') str
(";) p n
(  ) S
(die) K
( ") p
(Unrecognised Boolean condition: $cond) str
(";) p n
(}) N
() N
(=head2 B<value> method) C n
() N
(The value is either 'true' or 'false', as required by the B<xsi:boolean>) N
(type in XML Schema.) N
() N
(=cut) N
() p n
(our %) S
(values) K
( = \( ') p
(Y) str
(' => ') p
(true) str
(', ') p
(N) str
(' => ') p
(false) str
(' \);) p n
(BooleanField.pm) (Page 1/2) (Sep 26, 05 21:44) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() p n
(sub) K
( ) p
(value) L
( {) p n
(  ) S
(shift) K
(;) p n
(  ) S
(return) K
( $values{) p
(shift) K
( @{) p
(shift) K
(\(\)}};) p n
(}) N
() N
(1;) N
() N
(__END__) N
() N
(=head1 SEE ALSO) C n
() N
(L<DBIx::XMLServer::Field>) N
() N
(=head1 AUTHOR) N
() N
(Martin Bright E<lt>martin@boojum.org.ukE<gt>) N
() N
(=head1 COPYRIGHT AND LICENCE) N
() N
(Copyright \(C\) 2003-4 Martin Bright) N
() N
(This library is free software; you can redistribute it and/or modify) N
(it under the same terms as Perl itself.) N
() N
(=cut) N
(BooleanField.pm) (Page 2/2) (Sep 26, 05 21:44) title
border
grestore
(Printed by Michiel van Loon) rhead
(lib/DBIx/XMLServer/BooleanField.pm) (13/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 14
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(# $Id: DateField.pm,v 1.5 2005/10/05 20:39:34 mjb47 Exp $) c n
() p n
(package) K
( DBIx::XMLServer::DateField;) p n
(use) K
( ) p
(XML::LibXML) L
(;) p n
(use) K
( ) p
(Date::Manip) L
( ) p
(qw) K
(\( Date_Init UnixDate \);) p n
(our @ISA = \(') S
(DBIx::XMLServer::Field) str
('\);) p n
() N
(sub) K
( ) p
(BEGIN) L
( { Date_Init\(") p
(DateFormat = EU) str
("\); }) p n
() N
(=head1 NAME) C n
() N
(DBIx::XMLServer::DateField - date field type) N
() N
(=head1 DESCRIPTION) N
() N
(This class implements the built-in date field type of) N
(DBIx::XMLServer.  The B<where> and B<value> methods are overridden) N
(from the base class.) N
() N
(To use this field type, you must have the C<Date::Manip> package installed.) N
() N
(=head2 B<where> method) N
() N
(  $sql_expression = $date_field->where\($condition\);) N
() N
(The condition may consist of one of the comparison operators '=', '<', '>',) N
('>=' or '<=' followed by a date.  The date may be in any format understood) N
(by the C<Date::Manip> package, such as '1976-02-28' or 'two months ago'.) N
() N
(Alternatively, the condition may be empty, in which case the SQL expression) N
(is) N
() N
(  <field> IS NOT NULL .) N
() N
(If the condition is the character '!', then the SQL expression is) N
() N
(  <field> IS NULL .) N
() N
(=cut) N
() p n
(sub) K
( ) p
(where) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $cond = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $column = $self->) p
(select) K
(;) p n
(  ) S
(return) K
( ") p
($column IS NOT NULL) str
(" ) p
(if) K
( $cond ) p
(eq) K
( '';) p n
(  ) S
(return) K
( ") p
($column IS NULL) str
(" ) p
(if) K
( $cond ) p
(eq) K
( ') p
(!) str
(';) p n
(  ) S
(my) K
( \($comp, $date\) = \($cond =~ /\([=<>]+\)\(.*\)/\);) p n
(  ) S
(defined) K
( $comp ) p
(or) K
( ) p
(die) K
( ") p
(Unrecognised date condition: $cond\\n) str
(";) p n
(  $comp =~ /^\(=|[<>]=?\)$/ ) S
(or) K
( ) p
(die) K
( ") p
(Unrecognised date comparison: $comp\\n) str
(";) p n
(  ) S
(my) K
( $date1 = UnixDate\($date, ') p
(%Q) str
('\) ) p
(or) K
( ) p
(die) K
( ") p
(Unrecognised date: $date\\n) str
(";) p n
(  ) S
(return) K
( ") p
($column $comp ) str
(" . $date1;) p n
(}) N
() N
(=head2 B<value> method) C n
() N
(  $date = $date_field->value\(\\@results\);) N
() N
(The date is returned as 'YYYY-mm-dd', as required by the B<xsd:date> type) N
(of XML Schema.) N
() N
(=cut) N
() p n
(sub) K
( ) p
(value) L
( {) p n
(  ) S
(shift) K
(;) p n
(  ) S
(return) K
( UnixDate\() p
(shift) K
( @{) p
(shift) K
(\(\)}, ') p
(%Y-%m-%d) str
('\);) p n
(}) N
() N
(1;) N
() N
(DateField.pm) (Page 1/2) (Oct 05, 05 22:39) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(__END__) p n
() N
(=head1 SEE ALSO) C n
() N
(L<DBIx::XMLServer::Field>) N
() N
(=head1 AUTHOR) N
() N
(Martin Bright E<lt>martin@boojum.org.ukE<gt>) N
() N
(=head1 COPYRIGHT AND LICENCE) N
() N
(Copyright \(C\) 2003-4 Martin Bright) N
() N
(This library is free software; you can redistribute it and/or modify) N
(it under the same terms as Perl itself.) N
() N
(=cut) N
(DateField.pm) (Page 2/2) (Oct 05, 05 22:39) title
border
grestore
(Printed by Michiel van Loon) rhead
(lib/DBIx/XMLServer/DateField.pm) (14/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 15
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(# $Id: DateTimeField.pm,v 1.5 2005/10/05 20:39:34 mjb47 Exp $) c n
() p n
(package) K
( DBIx::XMLServer::DateTimeField;) p n
(use) K
( ) p
(XML::LibXML) L
(;) p n
(use) K
( ) p
(Date::Manip) L
( ) p
(qw) K
(\( Date_Init UnixDate \);) p n
(our @ISA = \(') S
(DBIx::XMLServer::Field) str
('\);) p n
() N
(=head1 NAME) C n
() N
(DBIx::XMLServer::DateTimeField - date and time field type) N
() N
(=head1 DESCRIPTION) N
() N
(This class implements the built-in date and time field type of) N
(DBIx::XMLServer.  The B<where> and B<value> methods are overridden) N
(from the base class.) N
() N
(=head2 B<where> method) N
() N
(  $sql_expression = $date_time_field->where\($condition\);) N
() N
(The condition may consist of one of the numeric comparison operators) N
('=', '>', '<', '>=' or '<=', followed by a date and time.  The date) N
(and time may be in any format understood by the C<Date::Manip>) N
(package, such as '2003-11-03 21:29:10' or 'yesterday at midnight'.) N
() N
(Alternatively, the condition may be empty, in which case the SQL expression) N
(is) N
() N
(  <field> IS NOT NULL .) N
() N
(If the condition is the character '!', then the SQL expression is) N
() N
(  <field> IS NULL .) N
() N
(=cut) N
() p n
(sub) K
( ) p
(BEGIN) L
( { Date_Init\(") p
(DateFormat = EU) str
("\); }) p n
() N
(sub) K
( ) p
(where) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $cond = ) p
(shift) K
(;) p n
(  ) S
(return) K
( ") p
($column IS NOT NULL) str
(" ) p
(if) K
( $cond ) p
(eq) K
( '';) p n
(  ) S
(return) K
( ") p
($column IS NULL) str
(" ) p
(if) K
( $cond ) p
(eq) K
( ') p
(!) str
(';) p n
(  ) S
(my) K
( $column = $self->) p
(select) K
(;) p n
(  ) S
(my) K
( \($comp, $date\) = \($cond =~ /\([=<>]+\)\(.*\)/\);) p n
(  ) S
(defined) K
( $comp ) p
(or) K
( ) p
(die) K
( ") p
(Unrecognised date condition: $cond\\n) str
(";) p n
(  $comp =~ /^\(=|[<>]=?\)$/ ) S
(or) K
( ) p
(die) K
( ") p
(Unrecognised date/time comparison: $comp\\n) str
(";) p n
(  ) S
(my) K
( $date1 = UnixDate\($date, ') p
(%q) str
('\) ) p
(or) K
( ) p
(die) K
( ") p
(Unrecognised date/time: $date\\n) str
(";) p n
(  ) S
(return) K
( ") p
($column $comp ) str
(" . $date1;) p n
(}) N
() N
(=head2 B<value> method) C n
() N
(The date and time is returned in the format 'YYYY-mm-ddThh:mm:ss', as ) N
(required by the B<xsi:datetime> type in XML Schema.) N
() N
(=cut) N
() p n
(sub) K
( ) p
(value) L
( {) p n
(  ) S
(shift) K
(;) p n
(  ) S
(return) K
( UnixDate\() p
(shift) K
( @{) p
(shift) K
(\(\)}, ') p
(%Y-%m-%dT%T) str
('\);) p n
(}) N
() N
(1;) N
() N
(__END__) N
() N
(=head1 SEE ALSO) C n
(DateTimeField.pm) (Page 1/2) (Oct 05, 05 22:39) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() C n
(L<DBIx::XMLServer::Field>) N
() N
(=head1 AUTHOR) N
() N
(Martin Bright E<lt>martin@boojum.org.ukE<gt>) N
() N
(=head1 COPYRIGHT AND LICENCE) N
() N
(Copyright \(C\) 2003-4 Martin Bright) N
() N
(This library is free software; you can redistribute it and/or modify) N
(it under the same terms as Perl itself.) N
() N
(=cut) N
(DateTimeField.pm) (Page 2/2) (Oct 05, 05 22:39) title
border
grestore
(Printed by Michiel van Loon) rhead
(lib/DBIx/XMLServer/DateTimeField.pm) (15/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 16
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(=head1 NAME) p n
() N
(DBIx::XMLServer::Field - base class for field types in DBIx::XMLServer) N
() N
(=head1 SYNOPSIS) N
() N
(  package MyField;) N
(  our @ISA = \('DBIx::XMLServer::Field'\);) N
() N
(  sub init { };) N
(  sub where { };) N
(  sub select { };) N
(  sub value { };) N
(  sub join { };) N
() N
(=head1 DESCRIPTION) N
() N
(This package is the base class for field type classes in) N
(DBIx::XMLServer.  Both built-in and user-supplied field types are) N
(derived from this class.  This documentation describes the methods of) N
(the class and how they should be overridden in derived classes.  All) N
(methods have sensible base implementations; many classes will only) N
(need to override one or two methods.) N
() N
(All methods of this class are executed inside B<eval>s; any errors) N
(thrown will be reported back to the user.) N
() N
(For examples on how to derive your own field types, see the built-in) N
(type packages.) N
() N
(=head2 B<init> method) N
() N
(  $field->init\(\);) N
() N
(The B<init> method is called at the end of the class constructor.) N
(Any initialisation needed by the class should be put here.  The) N
(default is to do nothing.) N
() N
(=head2 B<where> method) N
() N
(  $sql_expression = $field->where\($condition\);) N
() N
(The B<where> method takes a condition such as "=Fred*" or ">21" and) N
(converts it to an SQL expression such as S<"NAME LIKE FRED%"> or S<<) N
("AGE > 21" >>.  The argument is the remainder of a fragment of the) N
(HTTP query, after the initial XPath expression selecting the field has) N
(been removed.  This method will often want to call the B<select>) N
(method to get the SQL name of the field.  The default method returns) N
('1'.) N
() N
(=head2 B<select> method) N
() N
(  $sql_expression = $field->select\(\);) N
() N
(The B<select> method returns the SQL expression\(s\) for the field.  The) N
(default is to return the value of the B<expr> attribute of the field's) N
(B<< <sql:field> >> element.  This method may return a list, if the) N
(value of the field depends on more than one SQL expression.) N
() N
(=head2 B<value> method) N
() N
(  $xml_node = $field->value\(\\@results\);) N
() N
(The B<value> method takes the result of the SQL query and converts it) N
(to a fragment of XML.  The resulting fragment of XML replaces the B<<) N
(<sql:field> >> element in the output record.  The return value of this) N
(method should be: an C<XML::LibXML::Element>; a) N
(C<XML::LibXML::DocumentFragment>; a scalar value, which will be put) N
(into a new XML text node; or B<undef>, indicating a null value.) N
(Field.pod) (Page 1/2) (Nov 26, 04 15:32) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(Should the return value be B<undef>, the outcome in the result record) p n
(is determined by the field's B<null> attribute as described in) N
(L<DBIx::XMLServer>.  If the field is an attribute field, only scalar) N
(or B<undef> return values are allowed.) N
() N
(The argument is an array reference whose elements are the values of) N
(the columns in the result of the SQL SELECT statement.  This method) N
(should B<shift> its columns out of the array; normally only one column) N
(will be used, but if the B<select> method returns more than one) N
(expression then this method should remove the same number of values) N
(from the array.) N
() N
(The default behaviour is to shift one element from the array and) N
(return it as a scalar.) N
() N
(=head2 B<join> method) N
() N
(  $table = $field->join\(\)) N
() N
(This method returns the names of any tables which should be joined to) N
(the main table in order for this field to exist.  The default is to) N
(return the value of the B<join> attribute of the B<< <sql:field> >>) N
(element.) N
() N
(=head1 OBJECT DATA) N
() N
(There are two items of object data which may be useful to classes:) N
() N
(=over) N
() N
(=item Node reference) N
() N
(The expression C<< $self->{node} >> gives the C<XML::LibXML::Element>) N
(object representing the B<< <sql:field> >> element which defined this) N
(field.) N
() N
(=item Owner reference) N
() N
(The expression C<< $self->{XMLServer} >> gives the C<DBIx::XMLServer>) N
(element associated to the field.  The main use of this is probably to) N
(access the database handle stored in C<< $self->{XMLServer}->{dbh} >>,) N
(for purposes such as string escaping; and to get at the XML document) N
(object at C<< $self->{XMLServer}->{doc} >> for creating new nodes.) N
(Those wishing to access other data should look at the source to see) N
(what's there.) N
() N
(=back) N
() N
(=head1 SEE ALSO) N
() N
(L<DBIx::XMLServer>, L<DBIx::XMLServer::TextField>,) N
(L<DBIx::XMLServer::NumberField>, L<DBIx::XMLServer::DateField>,) N
(L<DBIx::XMLServer::DateTimeField>) N
() N
(=head1 AUTHOR) N
() N
(Martin Bright E<lt>martin@boojum.org.ukE<gt>) N
() N
(=head1 COPYRIGHT AND LICENCE) N
() N
(Copyright \(C\) 2003-4 Martin Bright) N
() N
(This library is free software; you can redistribute it and/or modify) N
(it under the same terms as Perl itself.) N
() N
(=cut) N
(Field.pod) (Page 2/2) (Nov 26, 04 15:32) title
border
grestore
(Printed by Michiel van Loon) rhead
(lib/DBIx/XMLServer/Field.pod) (16/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 17
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(# $Id: NumberField.pm,v 1.6 2005/05/26 15:01:04 mjb47 Exp $) c n
() p n
(package) K
( DBIx::XMLServer::NumberField;) p n
(use) K
( ) p
(XML::LibXML) L
(;) p n
(our @ISA = \(') S
(DBIx::XMLServer::Field) str
('\);) p n
() N
(=head1 NAME) C n
() N
(DBIx::XMLServer::NumberField - integer field type) N
() N
(=head1 DESCRIPTION) N
() N
(This class implements the built-in integer field type of) N
(DBIx::XMLServer.  Only the B<where> method is overridden from the base) N
(class.) N
() N
(=head2 B<where> method) N
() N
(  $sql_expression = $number_field->where\($condition\);) N
() N
(The condition may consist of one of the numeric comparison operators '=',) N
('>', '<', '>=' or '<=', followed by an integer.  The integer must match the) N
(regular expression '-?\\d+'.  The resulting SQL expression is simply) N
() N
(  <field> <condition> <value> .) N
() N
(If the operator is '=', then instead of a single integer a comma-separated) N
(list of integers may be given.  Then the SQL expression is) N
() N
(  <field> IN \(<value1>, <value2>, ...\) .) N
() N
(Alternatively, the condition may be empty, in which case the SQL expression) N
(is) N
() N
(  <field> IS NOT NULL .) N
() N
(If the condition is the character '!', then the SQL expression is) N
() N
(  <field> IS NULL .) N
() N
(=cut) N
() p n
(sub) K
( ) p
(where) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $cond = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $column = $self->) p
(select) K
(;) p n
(  ) S
(return) K
( ") p
($column IS NOT NULL) str
(" ) p
(if) K
( $cond ) p
(eq) K
( '';) p n
(  ) S
(return) K
( ") p
($column IS NULL) str
(" ) p
(if) K
( $cond ) p
(eq) K
( ') p
(!) str
(';) p n
(  ) S
(my) K
( \($comp, $value\) = \($cond =~ /\([=<>]+\)\(.*\)/\);) p n
(  ) S
(defined) K
(\($comp\) ) p
(or) K
( ) p
(die) K
( ") p
(Unrecognised number condition: $cond\\n) str
(";) p n
(  $comp =~ /^\(=|[<>]=?\)$/ ) S
(or) K
( ) p
(die) K
( ") p
(Unrecognised number comparison: $comp\\n) str
(";) p n
(  ) S
(if) K
(\($comp ) p
(eq) K
( ') p
(=) str
(' && $value =~ /^-?\\d+\(\\s*,\\s*-?\\d+\)+$/\) {) p n
(    ) S
(return) K
( ") p
($column IN \($value\)) str
(";) p n
(  }) N
(  $value =~ /^-?\\d+$/ ) S
(or) K
( ) p
(die) K
( ") p
(Unrecognised number: $value\\n) str
(";) p n
(  ) S
(return) K
( ") p
($column $comp $value) str
(";) p n
(}) N
() N
(1;) N
() N
(__END__) N
() N
(=head1 SEE ALSO) C n
() N
(L<DBIx::XMLServer::Field>) N
() N
(=head1 AUTHOR) N
() N
(Martin Bright E<lt>martin@boojum.org.ukE<gt>) N
(NumberField.pm) (Page 1/2) (Sep 26, 05 21:44) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
() C n
(=head1 COPYRIGHT AND LICENCE) N
() N
(Copyright \(C\) 2003-4 Martin Bright) N
() N
(This library is free software; you can redistribute it and/or modify) N
(it under the same terms as Perl itself.) N
() N
(=cut) N
(NumberField.pm) (Page 2/2) (Sep 26, 05 21:44) title
border
grestore
(Printed by Michiel van Loon) rhead
(lib/DBIx/XMLServer/NumberField.pm) (17/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 18
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(# $Id: TextField.pm,v 1.5 2005/05/26 15:01:04 mjb47 Exp $) c n
() p n
(package) K
( DBIx::XMLServer::TextField;) p n
(use) K
( ) p
(XML::LibXML) L
(;) p n
(our @ISA = \(') S
(DBIx::XMLServer::Field) str
('\);) p n
() N
(=head1 NAME) C n
() N
(DBIx::XMLServer::TextField - text field type) N
() N
(=head1 DESCRIPTION) N
() N
(This class implements the built-in text field type of DBIx::XMLServer.) N
(Only the B<where> method is overridden from the base class.) N
() N
(=head2 B<where> method) N
() N
(  $sql_expression = $text_field->where\($condition\);) N
() N
(This field type understands three types of condition:  a string comparison) N
(with wildcards; a regular expression test; and a not-null test.) N
() N
(=over) N
() N
(=item Condition: C<=wild*card?expression>) N
() N
(If the first character of the condition is '=', then the rest of the) N
(condition is interpreted as a string, possible containing wildcards,) N
(to which the column is to be compared.  First the string is escaped by) N
(the DBI system; then any characters '%' and '_' are escaped by) N
(prefixing with '\\'; then the characters '*' and '?'  are replaced by) N
('%' and '_' respectively.  The resulting SQL expression is one of) N
(the following:) N
() N
(  <field> = <string>) N
(  <field> LIKE <string>) N
() N
(depending on whether the string contains any wildcards.) N
() N
(=item Condition: C<~regex>) N
() N
(If the first character of the condition is a tilde '~', then the rest of) N
(the condition is interpreted as a regular expression.  It is escaped by) N
(the DBI system, and the SQL expression is) N
() N
(  <field> RLIKE <string> .) N
() N
(=item Condition: C<> \(empty\)) N
() N
(If the condition is empty, then the SQL expression is) N
() N
(  <field> IS NOT NULL .) N
() N
(=item Condition: C<!>) N
() N
(If the condition is the single character '!', then the SQL expression is) N
() N
(  <field> IS NULL .) N
() N
(=back) N
() N
(=cut) N
() p n
(sub) K
( ) p
(where) L
( {) p n
(  ) S
(my) K
( $self = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $cond = ) p
(shift) K
(;) p n
(  ) S
(my) K
( $column = $self->) p
(select) K
(;) p n
(  ) S
(return) K
( ") p
($column IS NOT NULL) str
(" ) p
(if) K
( $cond ) p
(eq) K
( '';) p n
(  ) S
(return) K
( ") p
($column IS NULL) str
(" ) p
(if) K
( $cond ) p
(eq) K
( ') p
(!) str
(';) p n
(TextField.pm) (Page 1/2) (Sep 09, 09 15:24) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(  ) p
(for) K
( \($cond\) {) p n
(    ) S
(s) K
(/^=// && ) p
(do) K
( {) p n
(      $_ = $self->{XMLServer}->{dbh}->quote\($_\);) N
(      ) S
(s) K
(/\([%_]\)/\\\\$1/g; ) p
(# Escape any SQL special characters) c n
(      ) p
(return) K
( \() p
(tr) K
(/*?/%_/\) ? ) p
(# Turn wildcards into SQL ones) c n
(        ") p
($column LIKE $_) str
(" : ") p
($column = $_) str
(";) p n
(    };) N
(    ) S
(s) K
(/^~// && ) p
(return) K
( ") p
($column ~ ) str
(" . $self->{XMLServer}->{dbh}->quote\($_\);) p n
(    /^$/ && ) S
(return) K
( ") p
($column IS NOT NULL) str
(";) p n
(    ) S
(die) K
( ") p
(Unrecognised condition: $_\\n) str
(";) p n
(  }) N
(}) N
() N
(1;) N
() N
(__END__) N
() N
(=head1 SEE ALSO) C n
() N
(L<DBIx::XMLServer::Field>) N
() N
(=head1 AUTHOR) N
() N
(Martin Bright E<lt>martin@boojum.org.ukE<gt>) N
() N
(=head1 COPYRIGHT AND LICENCE) N
() N
(Copyright \(C\) 2003-4 Martin Bright) N
() N
(This library is free software; you can redistribute it and/or modify) N
(it under the same terms as Perl itself.) N
() N
(=cut) N
(TextField.pm) (Page 2/2) (Sep 09, 09 15:24) title
border
grestore
(Printed by Michiel van Loon) rhead
(lib/DBIx/XMLServer/TextField.pm) (18/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage
%%Page: (1-2) 19
%%BeginPageSetup
/pagesave save def
sh 0 translate 90 rotate
%%EndPageSetup
iso1dict begin
gsave
llx lly 12 add translate
/v 0 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(<?xml version="1.0" encoding="utf-8"?>) p n
(<!-- $Id: xmlout.xsl,v 1.5 2005/10/05 20:39:34 mjb47 Exp $ -->) N
(<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform") N
(  version="1.0") N
(  xmlns:sql="http://boojum.org.uk/NS/XMLServer") N
(  exclude-result-prefixes="sql">) N
() N
(  <xsl:output method="xml"/>) N
(  <xsl:strip-space elements="*"/>) N
() N
(  <xsl:param name="args"/>) N
(  <xsl:param name="page"/>) N
(  <xsl:param name="query"/>) N
(  <xsl:param name="pagesize"/>) N
(  <xsl:param name="rows"/>) N
() N
(  <!-- Cut out the sql:template element -->) N
(  <xsl:template match="sql:template">) N
(    <xsl:apply-templates/>) N
(  </xsl:template>  ) N
() N
(  <!-- Remove the template record entirely -->) N
(  <xsl:template match="sql:record"/>) N
() N
(  <!-- Process various meta-information -->) N
(  <xsl:template match="sql:meta[@attribute]">) N
(    <xsl:attribute name="{@attribute}" namespace="{@namespace}">) N
(      <xsl:apply-templates select="." mode="meta"/>) N
(    </xsl:attribute>) N
(  </xsl:template>) N
(  <xsl:template match="sql:meta[not\(@attribute\)]">) N
(    <xsl:apply-templates select="." mode="meta"/>) N
(  </xsl:template>) N
(  <xsl:template match="sql:meta[@type='args']" mode="meta">) N
(    <xsl:value-of select="$args"/>) N
(  </xsl:template>) N
(  <xsl:template match="sql:meta[@type='page']" mode="meta">) N
(    <xsl:value-of select="$page"/>) N
(  </xsl:template>) N
(  <xsl:template match="sql:meta[@type='pagesize']" mode="meta">) N
(    <xsl:value-of select="$pagesize"/>) N
(  </xsl:template>) N
(  <xsl:template match="sql:meta[@type='query']" mode="meta">) N
(    <xsl:value-of select="$query"/>) N
(  </xsl:template>) N
(  <xsl:template match="sql:meta[@type='rows']" mode="meta">) N
(    <xsl:value-of select="$rows"/>) N
(  </xsl:template>) N
() N
(  <!-- Remove elements with a <sql:null type='omit'> child -->) N
(  <xsl:template match="*[sql:null/@type='omit']"/>) N
() N
(  <!-- Process <sql:null type='nil'> elements \(but not within ) N
(       <sql:attribute> elements - they'll be caught elsewhere -->) N
(  <xsl:template match="sql:null[@type='nil']">) N
(    <xsl:attribute name="nil" ) N
(      namespace="http://www.w3.org/2001/XMLSchema-instance">) N
(      <xsl:text>true</xsl:text>) N
(    </xsl:attribute>) N
(  </xsl:template>) N
() N
(  <!-- Remove <sql:null type='empty'> elements -->) N
(  <xsl:template match="sql:null[@type='empty']"/>) N
() N
(  <!-- Remove elements as per sql:omit attribute -->) N
(  <xsl:template match="*[@sql:omit='true']">) N
(    <xsl:variable name="content">) N
(      <xsl:apply-templates mode="check-omit" select="node\(\)"/>) N
(    </xsl:variable>) N
(xmlout.xsl) (Page 1/2) (Oct 05, 05 22:39) title
border
/v 1 store
/x0 x v get 3.147420 add sx cw mul add store
/y0 y v get bfs th add sub store
x0 y0 moveto
(    <xsl:if test="string\($content\)">) p n
(      <xsl:copy>) N
(        <xsl:apply-templates select="@*|node\(\)"/>) N
(      </xsl:copy>) N
(    </xsl:if>) N
(  </xsl:template>) N
() N
(  <xsl:template match="*[sql:null/@type='omit']" mode="check-omit" ) N
(    priority="2"/>) N
() N
(  <xsl:template match="*[not\(@sql:omit='true'\)]" mode="check-omit">) N
(    <xsl:value-of select="name\(\)"/>) N
(  </xsl:template>) N
() N
(  <!-- Process <sql:attribute> elements -->) N
(  <xsl:template match="sql:attribute[not\(sql:null/@type='omit'\)]">) N
(    <xsl:attribute name="{@name}">) N
(      <xsl:value-of select="."/>) N
(    </xsl:attribute>) N
(  </xsl:template>) N
() N
(  <!-- ...and those with a 'nil' null value inside them -->) N
(  <xsl:template match="sql:attribute[sql:null/@type='nil']" priority="2">) N
(    <xsl:attribute name="nil" ) N
(      namespace="http://www.w3.org/2001/XMLSchema-instance">) N
(      <xsl:text>true</xsl:text>) N
(    </xsl:attribute>) N
(  </xsl:template>) N
() N
(  <!-- Don't copy attributes corresponding to <sql:attribute> elements -->) N
(  <xsl:template match="@*[../sql:attribute/@name=name\(current\(\)\)]"/>) N
() N
(  <!-- Don't copy sql:* attributes -->) N
(  <xsl:template match="@sql:*"/>) N
() N
(  <!-- Do copy everything else -->) N
(  <xsl:template match="@*|node\(\)">) N
(    <xsl:copy>) N
(      <xsl:apply-templates select="@*|node\(\)"/>) N
(    </xsl:copy>) N
(  </xsl:template>) N
() N
(</xsl:stylesheet>) N
(xmlout.xsl) (Page 2/2) (Oct 05, 05 22:39) title
border
grestore
(Printed by Michiel van Loon) rhead
(lib/DBIx/XMLServer/xmlout.xsl) (19/19) (Wednesday September 09, 2009) footer
end % of iso1dict
pagesave restore
showpage

%%Trailer
end
%%EOF
